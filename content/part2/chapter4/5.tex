
有经验的C++开发者从来不会从零开始一个项目。他们会从各种来源整合代码，例如标准库、开源库、专有代码库，以及以前项目中的代码，应该在项目中自由地重用代码。本节首先解释了可以重用的不同类型的代码，然后是重用现有代码与自行编写代码之间的利弊。本节的最后一部分讨论了若决定重用现有代码时，选择要重用库的一些指导原则。

\begin{myNotic}{NOTE}
重用代码并不意味着复制粘贴现有代码！
\end{myNotic}

\mySubsubsection{4.5.1}{术语注释}

分析代码重用的优缺点之前，需要明确涉及的术语，并分类可重用的代码类型。可供重用的代码分为三个类别：

\begin{itemize}
\item
自己过去编写的代码

\item
同事编写的代码

\item
当前组织或公司外第三方编写的代码
\end{itemize}

可以重用的代码有以下几种：

\begin{itemize}
\item
独立函数或类。当重用自己或同事的代码时，通常会遇到这种类型。

\item
库。库是用于完成特定任务（如解析XML）或处理特定领域（如密码学）的代码集合。库中能找到的其他功能示例，包括线程和同步支持、网络和图形。

\item
框架。框架是设计程序时围绕其构建的代码集合，Microsoft Foundation Classes (MFC) 库为创建Microsoft Windows的图形用户界面应用程序提供了一个框架。框架通常规定了程序结构。

\item
应用程序，这种方法将代码重用推向极致。项目可能包括多个应用程序，也许需要一个网络服务器前端来支持新电子商务基础设施。可以捆绑整个第三方应用程序(例如：网络服务器)。
\end{itemize}

\begin{myNotic}{NOTE}
程序使用库，适应框架。库提供特定的功能，而框架对程序设计和结构至关重要。
\end{myNotic}

另一个经常出现的术语是应用程序编程接口（Application Programming Interface，简称API），是针对特定目的的库或代码体的接口。例如，开发者经常提到套接字API，套接字网络库的公开接口，而不是库本身。

\begin{myNotic}{NOTE}
API和库这两个术语并不等价。库指的是实现，而API指的是库的公开接口。
\end{myNotic}

本章的其余部分使用“库”这个术语来指代任何可重用的代码，无论它实际上是一个库、框架、应用程序，还是一个随机函数集合。

\mySubsubsection{4.5.2}{重用还是重写代码？}

重用代码规则在抽象概念上很容易理解。当涉及到细节时，会有些模糊。如何知道何时适合重用代码，以及重用哪些代码？这取决于具体情况。这里，介绍一些重用代码的优缺点。

\mySamllsection{重用的优点}

重用代码可以为项目带来巨大的优势：

\begin{itemize}
\item
可能不知道如何编写需要的代码，或者可能无法证明花时间编写代码的合理性。我们真的想编写处理格式化输出的代码吗？当然不是。这就是为什么要使用C++的标准std::format()或print()。

\item
由于不需要设计重用的应用程序的组件，这里的设计会更简单。

\item
重用的代码通常不需要调试。可以假设库代码是没有错误的，因为它已经经过广泛测试和使用。

\item
库处理的错误条件比第一次尝试编写的代码要多。在项目开始时，可能会忘记一些不常见的错误或边缘情况，并且会浪费时间在后期修复这些问题。重用的库代码通常已经经过广泛的测试，并且在此之前已经有许多开发者使用过，可以假设它正确处理了大多数错误。

\item
库通常在各种不同的硬件、不同的操作系统、不同的显卡等平台上进行过测试。有时，库包含了一些变通方法，以使它们能在特定平台上工作。

\item
库通常对不良用户输入持怀疑态度，无效的请求或对当前状态不合适的请求通常会得到适当的错误通知。例如，对数据库中不存在的记录进行查找的请求，或从未打开的数据库中读取记录的请求，库会对这些行为有明确的规定。

\item
重用领域专家编写的代码比自己编写代码更安全。除非是安全专家，否则不应尝试自己编写安全代码。若程序需要安全性或加密，请使用库。若在这些细节上出错，许多看似微小的错误都可能危及整个程序，甚至可能是整个系统的安全。

\item
库代码在不断完善。若重用代码，可以获得这些改进的好处，而不需要自己完成工作。若库的编写者正确地将接口与实现分离开来，可以通过升级库版本来获得这些好处，而不需要改变与库的交互方式。一个好的升级会修改底层实现，但不改变接口。
\end{itemize}

\mySamllsection{重用的缺点}

不过，重用代码也存在一些缺点：

\begin{itemize}
\item
当使用不是自己编写的库时，必须花时间理解接口和正确的使用方法，然后才能开始使用。项目的开始阶段，额外的投入会减慢程序设计和编码的速度。而好处是，因为需要维护的代码更少，最终的代码也会更简单，将在后期节省大量的时间。

\item
当编写自己的代码时，完全按照您的要求执行。库代码可能无法提供需要的功能。

\item
即使库代码提供了需要的功能，也可能无法提供期望的性能。性能总体上可能不佳，对特定用例来说可能很差，或者完全没有指定。

\item
使用库代码会引入一系列支持问题。若在库中发现了一个错误，需要怎么做？通常无法访问源代码，即使想修复它也无能为力。若已经在学习库接口和使用库上投入了大量时间，可能不想放弃，但会发现很难说服库开发者按照自己的时间表修复错误。另外，若使用的是第三方库，库作者已经停止对库的支持，要怎么办？决定使用一个无法获得源代码的库之前，请仔细考虑这个问题。

\item
除了支持问题，库还带来许可证问题，这些问题包括披露源代码、再发布费用（通常称为二进制许可证费用）、信用归属和开发许可证。在使用库之前，应该仔细检查许可问题，一些开源库要求将代码开源。

\item
重用代码需要信任因素。必须信任编写代码的人，假设他们做得很好。有些人喜欢对项目的所有方面（包括每一行源代码）都有控制权。

\item
升级到库的新版本可能会引起问题。升级可能会引入错误，这可能会在产品中产生致命的后果。与性能相关的升级可能在某些情况下优化性能，但在特定用例中却可能使其变得更糟。

\item
当使用二进制的库时，将编译器升级到新版本可能会引起问题。只能在库提供商提供兼容新版本编译器的二进制文件时升级编译器。
\end{itemize}

\mySamllsection{综合考虑做出决定}

现在已经熟悉了重用代码的术语、优点和缺点，将更好地准备做出是否重用代码的决定。想用C++为Microsoft Windows编写一个图形用户界面（GUI），应该使用MFC或Qt这样的框架。可能不知道如何编写在Windows中创建GUI的底层代码，更重要的是，不想浪费时间学习它。这种情况下，使用框架可以节省工作量。

然而，有时选择并不那么明显，不熟悉一个库并且只需要一个简单的数据结构，学习库以重用一个可以在几天内编写完成的组件可能并不值得。

最终，需要根据自己特定的需求做出决定。这通常是在自己编写所需的时间和寻找，并学习如何使用库解决问题所需的时间之间的权衡。仔细考虑前面列出的优点和缺点如何适用于您的具体情况，并决定哪些是重要因素。开发者总是可以改变主意，若正确处理了抽象，这可能很简单。

\mySubsubsection{4.5.3}{选择重用库的指导}

决定重用库、框架、同事的代码、整个应用程序或自己曾经的代码时，应该牢记以下几个原则，以选择正确的代码进行重用。

\mySamllsection{能力和局限性}

花时间熟悉代码，了解其功能及其限制非常重要。从文档和发布的接口或API开始，这将足以理解如何使用代码。若库没有在接口和实现之间提供清晰的分离，可能需要探索源代码本身（若提供的话）。与其他使用过代码的开发者交谈，他们可能能够解释其复杂性。应该从学习基本功能开始。若是一个库，提供了哪些功能？若是一个框架，的代码如何适配？应该从哪些类派生？需要自己编写哪些代码？还应该根据代码类型考虑特定问题。

选择库时，请记住以下几点：

\begin{itemize}
\item
在多线程程序中使用该库是否安全？

\item
该库是否对使用它的代码强加了特定的编译器设置？如果是，项目是否可以接受？

\item
该库是否依赖其他库
\end{itemize}

此外，可能需要对特定库进行更详细的研究：

\begin{itemize}
\item
需要哪些初始化和清理调用？

\item
如果需要从类派生，应该调用哪个构造函数？应该覆盖哪些虚成员函数？

\item
如果调用返回内存指针，谁负责释放内存：调用者还是库？如果由库负责，内存何时释放？强烈建议找出是否可以使用智能指针（请参阅第7章）来管理库分配的内存。

\item
调用的所有返回值（按值或引用）是什么？

\item
可能抛出的所有异常是什么？

\item
库调用检查哪些错误条件，其假设什么？如何处理错误？客户端程序如何得知错误？避免使用弹出消息框、在标准输出控制台打印消息或终止程序的库。客户端程序应该决定如何告知用户错误。
\end{itemize}

\mySamllsection{学习成本}

学习成本是开发者学习如何使用库所需的时间量。这不仅仅是开始使用库时的初始成本，而是随时间推移的重复成本。每当新团队成员加入项目时，都需要学习如何使用该库。

对于某些库来说，这个成本可能是相当可观的。如果在知名库中找到了所需的功能，我建议您使用它，而非使用一些不为人知的库。若标准库提供了需要的数据结构或算法，请使用标准库，请勿使用非标准库。

\mySamllsection{性能}

了解库或其他代码提供的性能非常重要。即使程序对性能不敏感，也应该确保使用的代码不会对性能产生糟糕的影响。

\mySamllsection{大O符号}

开发者通常使用大O符号来讨论和记录算法和库的性能。本节解释了算法复杂度分析和大O符号的基本概念，而没有涉及过多的不必要的数学。如果已经熟悉这些概念，可以跳过本节。

大O符号指定的是相对性能，而不是绝对性能。例如，大O符号不是说明一个算法以特定的时间运行，比如300毫秒，而是说明随着输入大小的增加，算法的表现如何。输入大小的例子包括排序算法要排序的项数、哈希表在键查找期间的元素数量，以及要在磁盘之间复制的文件大小。

\begin{myNotic}{NOTE}
大O符号只适用于其速度取决于输入的算法，不适用于没有输入的算法或其运行时间是随机的算法。实践中，会发现大多数感兴趣的算法的运行时间都取决于它们的输入，所以这个限制并不重要。
\end{myNotic}

大O符号将算法的运行时间指定为输入大小的函数，这也称为算法的复杂度。一个算法处理两倍数量的元素可能需要两倍的时间，如果处理200个元素需要1秒，处理400个元素需要2秒，处理800个元素需要4秒。图4.3以图形方式展示了这一点。据说这种算法的复杂度是输入大小的线性函数：

\myGraphic{0.5}{content/part2/chapter4/images/3.png}{图4.3}

大O符号这样总结算法的线性性能：O(n)。这里的O只是表示大O符号，而n代表输入大小。O(n)指定算法速度是输入大小的线性函数。

当然，并非所有算法的性能都与输入大小成线性关系。下表按性能从好到差的顺序总结了常见的复杂度：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|l|}
\hline
\textbf{\begin{tabular}[c]{@{}l@{}}算法复杂度\end{tabular}} &
\textbf{\begin{tabular}[c]{@{}l@{}}大O\end{tabular}} &
\textbf{解释} &
\textbf{示例} \\ \hline
\endfirsthead
%
\endhead
%
常量 &
O(1) &
\begin{tabular}[c]{@{}l@{}}运行时间与输入大小无关\end{tabular} &
\begin{tabular}[c]{@{}l@{}}访问数组中的单个元素。\end{tabular} \\ \hline
对数 &
O($log_2 n$) &
\begin{tabular}[c]{@{}l@{}}运行时间是输入大小以2为\\底的对数\end{tabular} &
\begin{tabular}[c]{@{}l@{}}使用二分查找在排序列表中查找元素。\end{tabular} \\ \hline
线性 &
O(n) &
\begin{tabular}[c]{@{}l@{}}运行时间与输入大小成正比\end{tabular} &
\begin{tabular}[c]{@{}l@{}}在未排序的列表中查找元素。\end{tabular} \\ \hline
线性对数 &
O($n log_2 n$) &
\begin{tabular}[c]{@{}l@{}}运行时间是线性函数乘以输入\\大小的对数\end{tabular} &
归并排序 \\ \hline
二次方 &
O($n^2$) &
\begin{tabular}[c]{@{}l@{}}运行时间是输入大小的平方\end{tabular} &
\begin{tabular}[c]{@{}l@{}}较慢的排序算法，比如选择排序。\end{tabular} \\ \hline
指数 &
O($2^n$) &
\begin{tabular}[c]{@{}l@{}}运行时间是输入大小的指数\end{tabular} &
\begin{tabular}[c]{@{}l@{}}优化旅行商问题。\end{tabular} \\ \hline
\end{longtable}

将性能指定为输入大小的函数，而非数字有两个优点：

\begin{itemize}
\item
平台无关。指定一段代码在一台计算机上运行200毫秒，并不能说明它在另一台计算机上的速度。如果不在同一台计算机上以相同的负载运行两种不同的算法，很难对它们进行比较。另一方面，作为输入大小函数的性能适用于任何平台。

\item
作为输入大小函数的性能用一个规格覆盖了算法可能遇到的所有输入。算法运行所需的具体时间（以秒计）只覆盖一个特定的输入，并且对其他输入没有提供信息。
\end{itemize}

\mySamllsection{性能技巧}

现在熟悉了大O符号，已经准备好了理解大多数性能文档。特别是C++标准库，可用大O符号描述其算法和数据结构的性能。然而，大O符号有时是不够的，甚至是误导性的。在考虑大O性能规格时，请考虑以下问题：

\begin{itemize}
\item
如果算法处理两倍的数据需要两倍的时间，这并不能说明最初的运行时间！如果算法编写得不好但扩展性好，仍然不是想要使用的，假设算法进行了不必要的磁盘访问。这可能不会影响大O时间，但对整体性能来说是非常糟糕的。

\item
在这个基础上，很难比较具有相同大O运行时间的两种算法。如果两种不同的排序算法都声称是O($n log_2 n$)，在没有运行自己的测试的情况下，很难判断哪种算法实际上更快。

\item
大O符号描述了算法的时间复杂度，是随着输入大小趋于无穷大时的情况。对于小输入，大O时间可能具有误导性。一个O($n^2$)算法可能在小输入尺寸上实际上比一个O($log_2 n$)算法表现更好。做出决定之前，需要考虑可能的输入。
\end{itemize}

除了考虑大O特性之外，还应该查看算法的其他性能方面。以下是参考指南：

\begin{itemize}
\item
需要考虑如何频繁地使用特定的一块库代码。有些人发现90/10规则很有帮助：大多数程序的90\%的运行时间花费在代码的10\%中（Hennessy和Patterson，《计算机系统结构：一种定量的方法》，第五版，2011年，Morgan Kaufmann）。若打算使用的库代码属于代码中经常使用的10\%部分，应该仔细分析其性能特征。另外，若属于经常忽视的90\%代码，就不应该花太多时间分析其性能，因为它不会对整体程序性能产生太大影响。第29章讨论了性能分析器，可以找到代码中的性能瓶颈。

\item
不要过度依赖文档。始终运行性能测试，以确定库代码是否提供了可接受的性能。
\end{itemize}

\mySamllsection{平台的局限性}

开始使用库代码之前，确保了解它在哪些平台上运行。如果想编写一个跨平台应用程序，确保选择的库也可跨平台。这听起来可能很简单，但即使声称是跨平台的库也可能在不同平台上存在细微差异。

此外，平台不仅包括不同的操作系统，还包括同一操作系统的不同版本。如果编写一个应在Solaris 8、9和10操作系统上运行的应用程序，确保使用的库也支持所有这些操作系统。若不能假设跨操作系统版本的前向或后向兼容性。也就是说，一个库能在Solaris 9上运行，并不意味着起也能在Solaris 10上运行，反之亦然。

\mySamllsection{许可限制}

使用第三方库通常会引入复杂的许可问题，有时需要向第三方供应商支付许可费以使用他们的库。也可能存在其他许可限制，包括国际出口限制，开源库有时以要求与之链接的代码也必须是开源的。

本章稍后将讨论开源库常用的几种许可。

\begin{myWarning}{WARNING}
若计划发布或销售开发的代码，请确保已经了解所使用的任何第三方库的许可限制。如果有疑问，请咨询专业从事知识产权的律师。
\end{myWarning}

\mySamllsection{寻求帮助}

使用库之前，确保了解提交错误的流程，并且意识到修复错误需要多长时间。可能的话，确定库将维护多长时间，以便进行相应地计划。

即使使用自己的组织内部的库，也可能引入支持问题。可能会发现，说服公司另一部分的同事修复他们库中的错误，与说服另一家公司的陌生人做同样的事情一样困难。实际上，这可能更难，因为你不是付费的客户。在使用内部库之前，请确保了解自己的组织内部的政治和组织问题。

对于重用整个应用程序，支持问题可能会变得更加复杂。如果客户遇到捆绑的网络服务器的问题，他们应该联系您，还是网络服务器供应商？在发布软件之前，请明确解决了这个问题。

使用库和框架有时一开始可能会感到可怖，有许多支持途径可供选择。首先，查阅随库提供的文档。如果该库广泛使用，例如标准库或MFC，应该能够找到一本关于该主题的书。对于标准库，可以参考第16至25章。如果有书和产品文档未涉及的具体问题，可以尝试在网上搜索。将的问题输入搜索引擎，以找到讨论该库的网页。当搜索“C++标准库介绍”时，会发现数百个关于C++和标准库的网站。此外，许多网站包含它们自己的特定主题新闻组或论坛，可以进行注册。

\begin{myWarning}{WARNING}
请注意：不要完全相信在网上读到的所有内容！网页不一定经过与印刷书籍和文档相同的审查过程，可能包含不准确的信息。
\end{myWarning}

\mySamllsection{原型}

当第一次坐下来使用一个新的库或框架时，写一个快速的示例原型通常是个好主意。尝试代码是熟悉库功能的最佳方式。应该考虑在开始设计程序之前就尝试使用该库，这样可以深入了解库的功能和局限性。这种实证测试还可以确定库的性能特征。

即使原型应用程序与最终应用程序大相径庭，花费在原型上的时间也不是浪费。不要感到有压力去编写实际应用程序的原型。编写一个测试想要使用的库功能的示例程序，关键要来熟悉这个库。

\begin{myWarning}{WARNING}
由于时间的限制，有时开发者会发现他们的原型逐渐演变成最终产品。如果拼凑了一个作为最终产品基础的示例原型，请确保不要以这种方式使用。
\end{myWarning}

\mySamllsection{开源库}

开源库是越来越受欢迎的可重用代码类别。开源的一般含义是，源码对任何人都可见。关于将源代码与所有分发捆绑的正式定义和法律规则，但关于开源软件最重要的要记住的是，任何人（包括您自己）都可以查看源代码。注意，开源不仅仅适用于库。实际上，最著名的开源产品Android操作系统，是Linux是另一个开源操作系统，Google Chrome和Mozilla Firefox是两个著名的开源网络浏览器。

\mySamllsection{开源运动}

不幸的是，开源社区在术语上存在一些混淆。首先，关于这一运动有两种竞争性的名称（有些人会说这是两个不同但相似的运动）。理查德·斯托曼（Richard Stallman）和GNU项目使用“自由软件”这个术语。注意，“自由”这个词并不意味着最终产品必须免费提供，开发者可以收取费用。相反，“自由”这个词指的是人们有权查看源代码、修改源代码并重新分发软件。将“自由”这个词是言论自由中的“自由”，而不是免费啤酒中的“免费”相比较。可以在\url{www.gnu.org}上阅读更多关于理查德·斯托曼和GNU项目的信息。

开源倡议（Open Source Initiative）使用“开源软件”这个术语来描述源代码必须可用的软件。与自由软件一样，开源软件并不要求产品或库必须免费提供。然而，与自由软件的一个重要区别是，开源软件并不要求拥有使用、修改和重新分发它的自由。可以在\url{www.opensource.org}上了解更多关于开源倡议的信息。

开源项目有许多可供选择的许可选项。一个项目可以使用GNU公共许可（GPL）的一个版本，但在GPL下使用一个库需要将自己的产品作为GPL开源。另一方面，开源项目可以使用像Boost软件许可、伯克利软件分发（BSD）许可、MIT许可、Apache许可等，这些许可允许在闭源产品中使用开源项目。这些许可中有些有不同的版本，有四个版本的BSD许可。开源项目的另一种选择是使用Creative Commons（CC）许可的六种版本之一。

一些许可要求将库的许可与最终产品一起包含，一些许可要求在使用库时给予署名。总之，许可都有一些微妙的不同，如果想在闭源项目中使用库，理解这些是非常重要的，\url{opensource.org/licenses}网站提供了批准的开源许可的全面概述。

由于“开源”这个名称比“自由软件”更清晰，因此本书使用“开源”来指代源代码可用的产品和库。选择这个名字并不是为了暗示对开源哲学的赞同超过自由软件哲学：只是为了便于理解。

\mySamllsection{寻找和使用开源库}

无论使用哪种术语，都可以从使用开源软件中获得好处，主要是功能。有许多开源C++库可用于各种任务，从XML解析、跨平台错误日志到使用人工神经网络的深度学习和数据挖掘。

虽然开源库不必提供免费分发和许可，但许多开源库都是免费的。通过使用开源库，可以节省许可费用，但并非总是可以自由修改开源库以满足特定的需求。

大多数开源库都可以在网上找到，搜索开源C++库XML解析会列出用于C++的XML库的链接。还有一些开源门户网站，可以从这里开始搜索，比如以下几个：

\begin{itemize}
\item
\url{www.boost.org}

\item
\url{www.gnu.org}

\item
\url{github.com/open-source}

\item
\url{www.sourceforge.net}
\end{itemize}

\mySamllsection{使用开源代码指南}

开源库也会带来了一些问题，并需要新的策略。首先，开源库通常是由人们在“业余”时间编写的。源代码通常对想要参与开发或修复错误的开发者都是可用的。作为一个好的编程公民，如果发现自己正在从开源库中受益，应该尝试为开源项目做出贡献。如果正为一家公司工作，可能会发现管理层对这一想法持反对态度，因为它不会直接为公司带来收入。然而，可能会从间接利益的层面说服管理层，如提升公司名称的曝光度和公司对开源运动的认可支持，应该允许你参与这一活动。

其次，由于其分布式开发和缺乏单一所有权的特性，开源库往往在支持问题上存在挑战。如果迫切需要修复一个库中的错误，通常自己动手修复比等待别人做更有效率。如果确实修复了错误，确保将这些修复推回到库的公共代码库中，一些许可甚至要求你这样做。即使没有修复任何错误，也要确保报告你发现的问题，这样其他开发者就不会浪费时间遇到同样的问题。

\mySamllsection{C++标准库}

作为C++程序员，将使用最重要的库是C++标准库。正如其名称所暗示的，这个库是C++标准的一部分，因此符合标准的编译器都必须包含。标准库不是单一的：包括几个不同的组件，其中一些已经在使用您甚至可能已经假设它们是核心语言的一部分。第16至25章将更详细地介绍标准库。

\mySamllsection{C标准库}

因为C++主要是C的超集，所以C标准库仍然可用。其功能包括数学函数，如abs()、sqrt()和pow()，以及错误处理助手，如assert()和errno。C标准库还包括用于操作字符数组作为字符串的功能，如strlen()和strcpy()，以及C风格的I/O函数，如printf()和scanf()。有关C库的详细信息，请查阅标准库参考资料；见附录B。

\begin{myNotic}{NOTE}
C++提供了比C更好的字符串和I/O支持。即使C++中提供了C风格的字符串和I/O例程，应该避免使用，而应选择C++字符串和格式化（第2章）以及I/O流（第13章）的支持。
\end{myNotic}

\mySamllsection{是否使用标准库}

标准库的设计优先考虑功能、性能和对称性。如果需要调试链表或平衡二叉树实现中的指针错误，或者调试一个排序算法，没有正确排序。如果正确使用标准库，几乎不需要自己进行那种编码或调试。另一个好处是，大多数C++开发者都知道如何使用标准库提供的功能。在项目中使用标准库时，新团队成员将比使用可能具有显著学习成本的第三方库更快地熟悉工作。第16至25章提供了标准库功能的更多信息。








