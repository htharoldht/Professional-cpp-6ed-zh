
单元测试是防止缺陷的第一道防线，但它们只是测试过程中的一个部分。更高层次的测试专注于产品部件如何协同工作，而不是单元测试相对狭窄的关注点。某种程度上，更高层次的测试更难以编写，因为不太清楚需要编写哪些测试，但只有测试了部件如何协同工作，才能说程序运行正常。

\mySubsubsection{30.4.1}{集成测试}

集成测试覆盖组件相遇的区域。与单元测试不同，集成测试通常涉及两个或更多类。集成测试擅长测试两个组件之间的交互，通常由两个不同的开发者编写。实际上，编写集成测试的过程揭示了设计之间的不兼容性。

\mySamllsection{集成测试的示例}

由于没有硬性规则来确定应该编写哪些集成测试，一些示例可能有助于了解何时使用集成测试。以下场景描述了适合集成测试的情况，但它们并不涵盖所有可能的情况。就像单元测试一样，随着时间的推移，将逐渐培养出对有用集成测试的直觉。

\mySamllsection{基于JSON的文件序列化}

假设项目包括一个持久层，用于将某些类型的对象保存到磁盘并从磁盘读取。使用JSON格式是当前流行的数据序列化方式，组件的逻辑分解可能包括一个位于自定义文件API之上的JSON转换层，这两个组件都可以进行很彻底的单元测试。JSON层可以有单元测试，确保不同类型的对象正确转换为JSON并从JSON填充。文件API可以有测试，用于在磁盘上读取、写入、更新和删除文件。

当这些模块开始协同工作时，集成测试就适用了。应该有一个集成测试，该测试通过JSON层将对象保存到磁盘，然后读取并将其与原始对象进行比较。因为该测试覆盖了两个模块，所以是一个基本的集成测试。

\mySamllsection{共享资源的读者和写者}

想象一个包含共享数据结构的程序。例如，一个股票交易程序可以有一个买入和卖出请求的队列。与接收股票交易请求相关的组件可以向队列添加订单，与执行股票交易相关的组件可以从队列中获取数据。可以对队列类进行大量单元测试，但在与实际使用它的组件一起测试之前，不知道设计时的假设是否正确。

好的集成测试使用股票请求组件和股票交易组件，作为队列类的客户端。可以编写一些示例订单，并确保它们通过客户端组件成功进入和退出队列。

\mySamllsection{第三方库的包装器}

集成测试并不总是需要发生在自己的代码的集成点上。很多时候，集成测试是为了测试与第三方库之间的交互。

例如，正在使用一个数据库连接库与关系型数据库系统进行通信。也许为该库构建了一个面向对象的包装器，该包装器增加了连接缓存的支持或提供了更友好的界面。这是一个重要的集成点，尽管包装器可能为数据库提供了更有用的接口，但它可能引入了对原始库的潜在误用。

编写包装器是一件好事，但如果引入了错误的包装器，那将是一场灾难。

\mySamllsection{集成测试技术}

实际编写集成测试时，集成测试与单元测试之间的界限往往很模糊。如果一个单元测试被修改以触及另一个组件，它是否突然变成了一个集成测试？从某种程度上说，答案无关紧要，因为好的测试就是好的测试，无论测试类型如何。我建议将集成测试和单元测试的概念作为两种测试方法，也别陷入给每个测试贴上类别的困境。

实现方面，集成测试通常使用单元测试框架编写，进一步模糊了它们的区别。事实上，单元测试框架提供了一种编写是/否测试，并产生有用结果的简单方法。无论测试是关注单一功能单元还是两个组件的交集，从框架的角度来看，这都一样。

然而，出于性能或组织原因，可能希望尝试将单元测试与集成测试分开。例如，团队可能决定每个人都必须在提交新代码之前运行集成测试，但对无关的单元测试可以稍微宽松一些，将两种类型的测试分开也增加了结果的价值。如果JSON类测试中发生测试失败，将清楚地表明是该类中的错误，而不是该类与文件API之间的交互错误。

\mySubsubsection{30.4.2}{系统测试}

系统测试在集成测试之上，甚至更高一个层次。这些测试审视程序的整体，系统测试经常使用虚拟用户来模拟人类与程序的交互。虚拟用户必须编写一个动作脚本来执行，其他系统测试依赖于脚本或一组固定的输入和预期输出。

与单元测试和集成测试一样，单个系统测试执行特定的测试并期望特定的结果，系统测试用于确保不同的特性以组合的方式进行工作。

理论上，一个完全系统测试的程序将，包含对每个特性的每个可能性的测试。这种方法很快就会变得难以处理，但仍然应该努力测试许多特性的组合。例如，一个图形程序可能有一个系统测试，该测试导入一个图像，对其进行旋转，应用模糊滤镜，转换为黑白，然后保存。该测试将保存的图像与包含预期结果的文件进行比较。

但关于系统测试，很难制定具体的规则，其高度依赖于实际应用程序。对于没有用户交互处理文件的程序，系统测试可以像单元测试和集成测试一样编写。对于图形程序，虚拟用户方法可能是最佳选择。对于服务器应用程序，可能需要构建模拟网络流量客户端的测试桩。重要的是，实际上是在测试程序的真实使用情况，而不仅仅是其一部分。

\mySubsubsection{30.4.3}{回归测试}

回归测试更像是一个测试概念，而不是特定类型的测试。其思想是，当特性工作正常，开发者往往会将其搁置一旁，并假设它将继续正常工作。不幸的是，新特性和其他代码更改往往会导致之前正常工作的功能出现问题。

回归测试通常作为对基本完成，且工作正常的特性进行“常规”检查。如果回归测试编写得很好，当引入导致特性故障的更改时，测试将不再通过。

如果公司有一支质量保证测试团队，回归测试可能以手动测试的形式出现。测试人员像用户一样进行一系列步骤，逐渐测试以前版本中工作的每个特性。如果仔细执行，这种方法既彻底又准确，但不可扩展。

另一个极端，可以构建一个完全自动化的系统，该系统以虚拟用户的方式执行每个功能。这将是脚本编写的一个挑战，但有一些商业和非商业软件包，可以简化各种类型应用程序的脚本编写。

一个中间方法称为冒烟测试。一些测试只会测试最重要的功能子集，这些功能应该工作。如果某个部分出现问题，应该立即显现。如果冒烟测试通过，可以用更严格的手动或自动化测试所取代。冒烟测试的概念最早是在电子学领域引入，在构建一个电路，包括不同组件如真空管、电阻器等之后，问题就是：“它组装正确吗？”一个解决方案是：“插上电源，打开，看看是否冒烟。”如果冒烟(短路产生高温)，设计可能错误，或者组装可能错误。通过观察哪个部分冒烟，从而判断错误。

一些缺陷就像噩梦一样：既可怕又反复出现。反复出现的缺陷令人沮丧，是对工程资源的浪费。为了防止缺陷反复出现，应该为修复的缺陷编写回归测试。通过为修复的缺陷编写测试，既证明了缺陷已经修复，又设置了一个警报，如果缺陷再次出现，会触发这个警报——例如，的更改回滚或以其他方式撤销，或者两个分支没有正确合并到主开发分支。当一个已经修复的缺陷的回归测试失败时，修复起来应该很容易，因为回归测试可以引用原始的缺陷编号，并描述第一次是如何修复的。






