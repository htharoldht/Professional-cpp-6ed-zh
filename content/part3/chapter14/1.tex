
没有程序可以孤立存在；它们都依赖于外部设施，例如与操作系统、网络和文件系统的接口，外部代码，如第三方库，以及用户输入。这些领域都需要响应程序可能遇到的问题。这些问题可以用异常这一通用术语来指代。即使是完美程序也会遇到错误和异常情况，编写专业计算机程序的开发者都需要学会错误处理。一些语言，如C，没有包含许多特定的错误处理，开发者通常依赖于函数的返回值和其他临时方法。其他语言，如Java，强制使用一种称为异常的语言特性作为错误处理机制。C++介于这两个极端之间，为异常提供语言支持，但不强制要求使用。但C++中不能忽略异常，一些基本操作，如内存分配，默认都会使用，而且标准库中还有几个类也会使用异常。

\mySubsubsection{14.1.1}{异常是什么？}

异常是一种代码片段通知另一个代码片段出现“异常”情况或错误的机制(不通过正常代码路径)。遇到错误的代码抛出异常，处理异常的代码会捕获异常，异常不遵循逐步执行的基本规则。当一段代码抛出异常时，程序控制立即停止逐步执行代码，并转换到异常处理程序，可能在同一函数中的下一行，也可能在堆栈上几个函数调用之外。如果各位读者喜欢体育，可以把抛出异常的代码想象成外场员将棒球扔回内场，最近的内场员（最近的异常处理程序）会接住这个球。图14.1显示了三个函数调用的假设堆栈。函数A()有异常处理程序，调用函数B()，B()调用函数C()，C()抛出异常。

\myGraphic{0.5}{content/part3/chapter14/images/1.png}{图 14.1}

图14.2显示了处理程序捕获异常。C()和B()的堆栈帧已移除，只剩下A()。

\myGraphic{0.5}{content/part3/chapter14/images/2.png}{图 14.2}

大多数现代编程语言，如C\#和Java，都支持异常处理，所以C++也完全支持异常。如果你是一个C语言开发者，那么异常对于你来说就是一个新鲜事物；但当你了解了它们，可能就不想回去使用C语言进行开发了。

\mySubsubsection{14.1.2}{C++中的异常}

有时，程序会在运行时不可避免的出现错误，但大多数C和C++程序中的错误处理即混乱又临时。事实上C语言有错误处理标准，许多C++程序也继承了这一标准，使用整数函数返回码和errno宏来表示错误。每个线程都有自己的errno值，errno为一个线程局部的整型变量，函数可以使用将错误码返回给调用函数。

不幸的是，整数返回码和errno不一致。一些函数可能选择返回0表示成功，返回-1表示错误。如果返回-1，还会将errno设置为错误。其他函数返回0表示成功，非零表示错误，实际返回值指定错误码。这些函数不使用errno。还有一些函数返回0表示失败，而不是成功，可能是因为在C和C++中0始终为false。

这些不一致会导致问题，开发者遇到一个新函数时，经常会假设返回码与其他类似函数相同，但情况并非总是如此。例如，在Solaris 11操作系统中，有两种不同的同步对象库：可移植操作系统接口（POSIX）版本和Solaris版本。POSIX版本中初始化信号量的函数称为sem\_init()，Solaris版本中初始化信号量的函数称为sema\_init()。这还不够混乱，这两个函数处理错误码的方式也不相同！sem\_init()在出错时返回-1并设置errno，而sema\_init()直接将错误码作为正整数返回，并不设置errno。

另一个问题是，C++中函数的返回类型只能有一种，如果需要返回错误和值，必须使用另一种机制。一个解决方案是返回一个std::pair或tuple，这是一个可以用来存储两种或更多类型的对象。pair类在第1章中介绍过，而tuple将在后面介绍标准库的章节中介绍。从C++23开始，可以从函数返回一个std::expected实例，它可能包含函数的结果，如果出现问题，则包含错误，第24章详细介绍了expected。另一个选择是定义自己的包含多个值的struct或class，并从函数返回该struct或class的实例。还有一个选项是通过引用参数返回值或错误，或者使错误码成为返回类型的一种可能值，比如nullptr指针。这些解决方案中，调用者负责显式检查函数返回的错误，如果它自己不处理错误，应该将错误告知给调用者。不幸的是，这通常会导致关于错误信息的丢失。

C程序员可能熟悉一种称为setjmp()/longjmp()的机制。这个机制在C++中不能正确使用，因为它绕过了栈上的作用域析构函数。即使是在C程序中，也应该尽量避免使用；因此，本书不会介绍如何使用它。

异常为错误处理提供了一个更简单、更一致、更安全的机制。异常相对于C和C++中的临时方法有几个优势：

\begin{itemize}
\item
当返回码用作错误报告机制时，可能会忘记检查返回码，并在本地处理或向上传播。第1章中引入的[[nodiscard]]属性，提供了一个可能的解决方案来防止忽略返回码，但它也不是万无一失的。不能忘记或忽略异常：如果程序未能捕获异常，程序将终止运行。

\item
当使用整数返回码时，通常不包含足够的信息。可以使用异常从发现错误的代码，传递信息到处理代码中。异常也可以用来传递错误之外的信息，不过包括我在内的许多开发者认为这是对异常机制的滥用。

\item
异常处理可以跳过调用堆栈的级别，一个函数可以处理在堆栈下几个函数调用中发生的错误，而中间函数中不需要错误处理代码。返回码要求调用堆栈逐级清理，并显式地传播错误码。
\end{itemize}

以前的一些编译器中，异常处理为具有异常处理器的函数增加了一点开销。对于大多数现代编译器来说，在非抛出情况下没有或没有开销，只有在实际抛出时才会有一些开销，这种权衡并不是坏事。异常不应该用于控制程序的标准执行流程，比如：从函数返回一个值。异常应该只用于处理通常在正常程序使用中不会遇到的异常事件，例如：从磁盘上的文件读取时失败。在使用异常实际上在非错误情况下，会比使用错误返回码的实现产生更快的代码。

在C++中并不强制进行异常处理，但在Java中强制。Java函数如果没有指定可能抛出的异常列表，则不允许抛出任何异常。而在C++中，情况正好相反：一个函数可以抛出异常，除非使用noexcept关键字明确指定它不会抛出异常，这一点将在本章后面介绍！

\mySubsubsection{14.1.3}{推荐}

我推荐将异常作为错误处理的实用机制，因为异常提供的结构和错误处理形式化利大于弊，本章的其余部分将重点讨论异常。另外，许多流行的库，如标准库和Boost，也都使用异常，所以需要处理好它们。








