
C++中的关键字static有几种用法，看起来都不相关。重载这个关键字的部分原因是，避免向语言中引入新的关键字。本章前面在讨论链接的上下文中，提到了这个关键字的一种用法。其他用法将在本节进行介绍。

\mySubsubsection{11.6.1}{静态数据成员和成员函数}

可以声明类的静态数据成员和成员函数。与非常量数据成员不同，静态数据成员不是每个对象的一部分。数据成员只有一个副本，存在于该类的对象之外。

静态成员函数同样位于类级别，而非对象级别。静态成员函数不是在特定对象的上下文中执行，没有隐式的this指针，所以静态成员函数不能标记为const。

第9章提供了静态数据成员和成员函数的示例。

\mySubsubsection{11.6.2}{函数中的静态变量}

C++中static关键字的另一个用途是，创建在退出和进入其作用域之间保持其值的变量。例如，函数内的静态局部变量就像一个全局变量，但只能在该函数内访问。静态变量的一个常见用途是“记住”是否为某个特定函数执行了特定的初始化。

\begin{cpp}
void performTask()
{
    static bool initialized { false };
    if (!initialized) {
        println("initializing");
        // Perform initialization.
        initialized = true;
    }
    // Perform the desired task.
}
\end{cpp}

静态变量可能会令人困惑，通常有更好的方法来构建代码。这种情况下，可能想写一个类，其构造函数执行所需的初始化。

\begin{myNotic}{NOTE}
避免使用独立的静态变量，尽可能在对象内维护状态。
\end{myNotic}

然而，有时它们可能很有用。一个例子是会在第33章中介绍的Meyers单例设计模式。

\begin{myNotic}{NOTE}
performTask()的实现线程不安全；包含竞争条件。多线程环境中，需要使用原子操作或其他机制来同步多个线程。多线程在第27章中有详细的介绍。
\end{myNotic}

\mySubsubsection{11.6.3}{非局部变量的初始化顺序}

结束静态变量这个主题之前，考虑一下这类变量的初始化顺序。程序中所有的全局和静态变量在 main() 开始之前都会初始化，给定源文件中的变量按照在源文件中出现的顺序进行初始化。例如，Demo::x 保证在 y 之前初始化：

\begin{cpp}
class Demo
{
    public:
        static int x;
};
int Demo::x { 3 };
int y { 4 };
\end{cpp}

然而，C++ 并不提供关于不同源文件中，非局部变量初始化顺序的规范或保证。如果在一个源文件中有全局变量 x，在另一个源文件中有全局变量 y，无法知道哪个会先初始化。如果一个全局或静态变量依赖于另一个，这可能会成为问题。回想一下，对象的初始化意味着执行它们的构造函数。一个全局对象的构造函数可能会访问另一个全局对象，假设其已经构造。如果这两个全局对象在两个不同的源文件中声明，不能指望一个在另一个之前构造，并且无法控制初始化的顺序。这个顺序对于不同的编译器，甚至是同一编译器的不同版本都可能不同，并且当简单地为项目添加另一个文件时，这个顺序可能发生改变。

\begin{myWarning}{WARNING}
不同源文件中非局部变量的初始化顺序未定义。
\end{myWarning}

\mySubsubsection{11.6.4}{非局部变量的销毁顺序}

非局部变量按照它们初始化的相反顺序销毁。不同源文件中的非局部变量以未定义的顺序初始化，销毁的顺序也未定义。



















