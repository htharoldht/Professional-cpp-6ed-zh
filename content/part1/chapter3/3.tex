
分解是将代码分解为更小片段。编码中，没什么比打开一个源代码文件，却发现有300行长的函数和大量嵌套的代码块更让人望而却步的了。理想情况下，每个函数应该完成一个任务。非常复杂的子任务，都应该分解成单独的函数。有人问你一个函数是做什么的，你回答说：“首先它做A，然后做B；然后，如果C，它做D；否则，它做E，”那么应该为A、B、C、D和E实现有单独的辅助函数。

分解并不是一门精确的科学。一些开发者会说，没有函数应该长于打印出来的一页。这也许是个不错的经验法则，但肯定能找到一个迫切需要分解的四分之一页的代码。另一个经验法则是，若眯着眼睛，不看实际的代码内容，只看代码的格式，在任何一个区域都不应该显得太密集。图3.2和图3.3显示了故意模糊处理的代码，这样就不会关注内容，图3.3中的代码分解的比图3.2更好。

\myGraphic{0.3}{content/part1/chapter3/images/2.png}{图 3.2}

\myGraphic{0.3}{content/part1/chapter3/images/3.png}{图 3.3}

\mySubsubsection{3.3.1}{通过重构进行分解}

有时，当喝了几杯咖啡，进入编程状态时，会开始快速编码，最终的代码确实完成了应该做的事情，但远非美观，所有开发者都会时不时有这样的经历。短时间的激烈编码，有时是项目过程中最富有成效的时刻。随着时间的推移，代码的修改也会导致代码变得密集。随着新需求和错误修复的出现，现有代码会进行小幅修改。计算术语“cruft”指的是代码中逐渐积累的少量代码，最终将一段曾经优雅的代码变成了一堆补丁和“特殊”情况。

重构是对代码进行结构重组的行为。《重构(第二版):改善既有代码的设计》（附录B中提到的参考文献）一书是关于重构的书籍之一。以下列表包含了一些重构代码的示例技术：

\begin{itemize}
\item
更多的抽象化:

\begin{itemize}
\item
封装数据成员:将数据成员设为private，并通过getter和setter成员函数对其进行访问。

\item
泛化类型:创建更通用的类型，以允许更多的代码共享。
\end{itemize}

\item
将代码分解成更多逻辑片段:

\begin{itemize}
\item
提取成员函数：将较大成员函数的一部分转换为新的成员函数，便于理解。

\item
提取类：将现有类中的部分代码移动到新类中。
\end{itemize}

\item
改进代码名称和位置:

\begin{itemize}
\item
移动成员函数或移动数据成员:移动到更合适的类或源文件中。

\item
重命名成员函数或重命名数据成员:更改名称以更好地显示其目的性。

\item
上拉:在面向对象编程中，移动到基类。

\item
下推:在面向对象编程中，移动到派生类。
\end{itemize}
\end{itemize}

无论代码最初是作为一块密集的、难以阅读的cruft开始的，还是逐渐演变成那样，重构都是必要的，以定期清除代码中积累的临时解决方案。通过重构，可以重新访问现有代码并重写，使其更具可读性和可维护性。重构是重新审视代码分解的机会。若代码的目的已经改变，或者最初就没有分解，那么重构代码时，请眯着眼睛看看，确定是否需要将其分解为更小的部分。

重构代码时，需要依赖一个测试框架来捕获可能引入的缺陷。第30章讨论的单元测试，特别适合在重构过程中捕捉错误。

\mySubsubsection{3.3.2}{按设计分解}

若使用模块化分解，并且在编写每个模块和函数时考虑哪些部分可以推迟实现，程序的每个功能越单一，代码更有组织性。

每位开发者都应该在编写代码之前，对自己的程序进行设计。

\mySubsubsection{3.3.3}{本书中的分解}

各位将在本书的许多示例中看到分解的情况。许多情况下，会引用一些函数，它们与示例无关，并且占用太多空间，所以没有展示其具体实现。
