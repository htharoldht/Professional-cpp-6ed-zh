
C++语言常视为“更好的C语言”或“C语言的超集”，其设计为面向对象的C，所以称之为“带类的C”。后来，C语言的许多令人烦恼和粗糙的问题得到了解决。因为C++是基于C的，若是一个经验丰富的C语言开发者，肯定会在本节中看到的一些熟悉的语法。当然，这两种语言也有不同之处。C23标准规范文档的篇幅不到800页，而C++23标准规范文档的篇幅超过2000页。若你是一名C语言开发者，或是熟悉其他语言(如Java、C\#、Python等)的开发者，请留意自己不熟悉的语法!

\mySubsubsection{1.1.1.}{必不可少的“Hello, World”}

下面的代码是最简单的C++程序。若使用的是旧版本的C++，import std;std::println()会无法识别，需要使用替代方案（稍后会讨论）。

\begin{cpp}
// 01_helloworld.cpp
import std;

int main()
{
    std::println("Hello, World!");
    return 0;
}
\end{cpp}

这段代码会在屏幕上输出“Hello, World!”。这是一个简单的程序，并展示了关于C++程序格式的相关概念:

\begin{itemize}
\item
注释

\item
导入模块

\item
main()函数

\item
屏幕输出

\item
函数返回值
\end{itemize}

这些概念将在接下来的章节中进行简要解释。

\mySamllsection{注释}

程序的第一行是注释，这是一条仅为开发者存在的信息，编译器会忽略它。C++中，有两种描述注释的方法。可以使用两个正斜杠来表示该行后面的内容是注释:

\begin{cpp}
// 01_helloworld.cpp
\end{cpp}

同样可以通过使用多行注释来实现。多行注释以/*开始，以*/结束。下面的代码展示了一个多行注释的作用:

\begin{cpp}
/* This is a multiline comment.
   The compiler will ignore it.
*/
\end{cpp}

注释将在第3章中详细介绍。

\mySamllsection{导入模块}

模块是C++20的四大新特性之一，取代了旧的以头文件为机制的方式。若想使用某个模块的功能，只需简单地导入该模块，可以通过导入声明来实现。从C++23开始，可以通过导入一个单一的标准命名模块来访问整个C++标准库，这个标准模块叫做std。Hello, World的第一行导入了这个标准模块：

\begin{cpp}
import std;
\end{cpp}

若没有导入该模块，将无法执行进行屏幕输出。

若没有C++23的标准命名模块支持，必须显式导入代码所需的头文件。由于标准库中有超过100个头文件，并不总是清楚需要导入哪个特定的头文件才能使用某个特定功能。作为一个参考，附录C中，列出了C++标准库的所有头文件，包括它们内容的简短描述。例如，“Hello, World”中，可以不导入标准命名模块std，只导入代码需要的头文件即可。这个例子中，代码只需要导入<print>来获取文本的输出功能。导入命名模块std时，不使用尖括号，但在导入单个头文件时，需要使用尖括号：

\begin{cpp}
import <print>;
\end{cpp}

因为本书是一本关于C++23的书，所以在所有地方都使用了模块。C++标准库提供的所有功能都包含在定义良好的头文件中。本书中的大多数示例只是导入std命名模块，而不是单个头文件，但会指出功能是哪个头文件提供的。

模块不仅限于标准库，也可以编写自己的模块来提供自定义类型和功能。

\begin{myNotic}{NOTE}
若正在使用的编译器尚未完全支持模块，可将头文件导入声明替换为\#include预处理指令。
\end{myNotic}

\mySamllsection{编译器如何处理源码}

简言之，构建C++程序需要三个步骤。技术上讲，编译过程中还有更多的阶段，现阶段这个简化就够了。

\begin{enumerate}
\item
首先，代码通过预处理运行，预处理器识别有关代码的元信息并处理预处器指令，例如\#include指令。处理所有预处理指令的源文件称为\textbf{翻译单元}。

\item
接下来，所有翻译单元独立编译或翻译成机器可读的文件，其中对函数等的引用尚未定义。

\item
解析这些引用在最后阶段由链接器完成，其会将所有的目标文件链接到可执行文件中。
\end{enumerate}

\CXXTwentythreeLogo{-40}{-50}
\begin{myNotic}{NOTE}
从C++23开始，标准规定C++编译器必须接受使用UTF-8编码的源代码文件。第21章讨论了不同的编码，包括UTF-8。我建议您配置工具链以使用UTF-8。这将提高文件在不同平台之间的可移植性，并允许源文件中使用非英文字符。

为了在Microsoft Visual C++中启用UTF-8支持，请在项目属性 -> 配置属性 -> C/C++ -> 命令行 下的附加选项设置中添加 /utf-8 选项。对于GCC，请使用命令行选项 -finput-charset=UTF-8。Clang默认认为所有文件都是UTF-8编码。
\end{myNotic}

\mySamllsection{预处理指令}

若编译器尚不支持模块，需要用\#include头文件来代替导入模块或头文件。也就是说，显式的导入声明，如import <print>;，需要用\#include预处理指令替换：

\begin{cpp}
#include <print>
\end{cpp}

预处理的指令以\#字符开头，例如\#include。\#include指令告诉预处理器从<print>头文件中获取所有内容，并将其复制到当前文件中。<print>头文件提供了将文本打印到屏幕的功能。

第11章对预处理指令进行了更详细的讨论。

\mySamllsection{main()函数}

当然，main()是程序的起始点。main()的返回类型是int，表示程序的结果状态。main()函数可以没有参数，或者两个参数：

\begin{cpp}
int main(int argc, char** argv)
\end{cpp}

argc给出传递给程序的参数数量，而argv包含这些参数。其中，argv[0]可能是程序名称，也可能是空字符串，所以不要依赖它，而应该使用特定于平台的函数来获取程序名称。另外，包含在argv中的实际参数，需要从索引1开始计算。

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{屏幕输出}

C++23前，可使用I/O流将文本输出到屏幕。流会在下一节和第13章中进行了简要介绍。C++23引入了一个新的、更易于使用的机制来输出文本到屏幕，这在本书的每个代码片段中都使用到了：std::print()和println()，都在<print>中定义。

第2章详细讨论了std::print()和println()，用于将字符串格式化和输出到屏幕上。其基本使用的方式非常直接，其最基本的形式中，println()可以用来打印一行文本，该文本输出后会自动换行：

\begin{cpp}
std::println("Hello, World!");
\end{cpp}

println()的第一个参数是字符串，其中可以包含替换字段，这些字段将由作为第二个和后续参数传递的值替换。可以在每个字段旁边包含大括号\{\}来指示替换字段的位置。例如：

\begin{cpp}
std::println("There are {} ways I love you.", 219);
\end{cpp}

例子中，数字219将插入到字符串中，所以输出为：

\begin{shell}
There are 219 ways I love you
\end{shell}

可以根据需要设置任意数量的替换字段，例如:

\begin{cpp}
std::println("{} + {} = {}", 2, 4, 6);
\end{cpp}

这个例子中，每个字段都是按顺序应用的，所以结果输出为:

\begin{shell}
2 + 4 = 6
\end{shell}

关于替换字段的格式还有很多要说的，但这是第2章的内容。

若使用print()，而不是println()，输出的文本将不会以换行。

\mySamllsection{输入输出流}

若编译器还不支持C++23，在使用std::print()和println()函数，则必须使用I/O流重新实现。

输入输出流会在第13章中深入的介绍，但其基本概念很简单。可以将输出流想象成数据槽通道，投入的东西都会输出。std::cout是与用户控制台或标准输出对应的通道。还有其他的通道，包括std::cerr，输出到错误控制台。<{}<操作符将数据投入通道中。输出流允许多种类型的数据在单行代码中顺序发送到通道中。以下代码输出文本，然后是一个数字，最后是文本：

\begin{cpp}
std::cout << "There are " << 219 << " ways I love you." << std::endl;
\end{cpp}

从C++20开始，推荐使用std::format()，其定义在<format>中，对字符串进行格式化。format()函数使用与print()和println()相同的替换字段概念，这会在第2章中详细讨论。用其来重写前面的语句也很简单：

\begin{cpp}
std::cout << std::format("There are {} ways I love you.", 219) << std::endl;
\end{cpp}

若编译器尚不支持print()和println()，可以使用cout、format()和endl。假设有以下代码：

\begin{cpp}
std::println("{} + {} = {}", 2, 4, 6);
\end{cpp}

将println()替换为format()，将结果流式传输到cout，并添加endl输出:

\begin{cpp}
std::cout << std::format("{} + {} = {}", 2, 4, 6) << std::endl;
\end{cpp}

std::endl表示行结束。当输出流遇到std::endl时，会将输出到目前为止已发送到通道中的所有内容，并移动到下一行。表示行结束的另一种方法是使用\verb|\|n字符。\verb|\|n字符是一个转义字符，是一个换行字符。转义字符可以在任何带引号的文本字符串中使用，下表展示几个常见的:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|}
\hline
\textbf{转义字符}         & \textbf{含义}                                             \\ \hline
\endfirsthead
%
\endhead
%
\textbackslash{}n                & 换行:将光标移到下一行的开头 \\ \hline
\textbackslash{}r &
\begin{tabular}[c]{@{}l@{}}回车:将光标移到当前行的开头，但不能换行\end{tabular} \\ \hline
\textbackslash{}t                & 制表符                                                          \\ \hline
\textbackslash{}\textbackslash{} & 反斜杠字符                                          \\ \hline
\textbackslash{}"                & 引号                                               \\ \hline
\end{longtable}

\begin{myWarning}{WARNING}
endl会将新行插入到流中，并将当前在其缓冲区中的所有内容输出到通道中。所以不建议过度使用endl，尤其在循环中，这会影响性能。另一方面，在流中插入\textbackslash{}n也会插入新行，但不会自动刷新缓冲区。
\end{myWarning}

默认情况下，print()和println()将文本输出到标准输出控制台std::cout。也可以输出到错误控制台std::cerr:

\begin{cpp}
std::println(std::cerr, "Error: {}", 6);
\end{cpp}

流也可以用来接受来自用户的输入。最简单的方法是对输入流使用操作符>{}>。cin输入流可接受来自用户的键盘输入:

\begin{cpp}
import std;
int main()
{
    int value;
    std::cin >> value;
    std::println("You entered {}", value);
}
\end{cpp}

操作符>{}>在读取值后遇到空格字符时停止输入，所以不能使用操作符读取包含空格的文本。用户的输入可能很棘手，不知道用户将输入什么样的数据。第13章详细讨论了输入流，包括如何读取带有空格的文本。

若是C++新手，并且具有C背景，可能会想知道是否可以使用printf()和scanf()函数。虽然这些函数仍然可以在C++中使用，但强烈建议使用现代的print()、println()和format()函数和流库，其主要原因是因为printf()和scanf()系列函数不提供类型安全的保障。

\mySamllsection{从函数返回}

“Hello, World”程序的最后一行:

\begin{cpp}
return 0;
\end{cpp}

由于这是main()函数，从它返回将控制权返回给操作系统。其传递值0，这通常向操作系统发出信号，表明在执行程序时没有错误。对于错误情况，可以返回非零值。

main()中的return语句是可选的。若不写一个，编译器将隐式地添加return 0;。

\mySubsubsection{1.1.2.}{命名空间}

命名空间解决了不同代码段之间的命名冲突问题。例如，正在编写一些代码，其中包含一个名为foo()的函数。某天，决定开始使用第三方库，该库也有一个foo()函数，这时编译器无法知道代码中引用的是哪个版本的foo()。若不能更改库的函数名，就要更改自己的函数名，这是一件非常痛苦的事情。

这种情况下，命名空间可以发挥作用，可以定义定义名称的上下文。将代码放置在命名空间，请将其包含在命名空间块中:

\begin{cpp}
namespace mycode {
    void foo()
    {
        std::println("foo() called in the mycode namespace");
    }
}
\end{cpp}

将自己的foo()放在命名空间mycode中，可以将其与第三方库提供的foo()函数隔离。要调用支持命名空间的foo()版本，请使用::将命名空间添加到函数名之前，这也称为作用域解析操作符:

\begin{cpp}
mycode::foo(); // Calls the "foo" function in the "mycode" namespace
\end{cpp}

属于mycode命名空间块的代码，都可以调用同一命名空间内的其他代码，而无需显式添加命名空间。这种隐式命名空间的做法，有助于提高代码的可读性。也可以使用using指令来消除命名空间的前缀。该指令告诉编译器，后续代码正在使用指定命名空间中的名称，所以下面的代码隐藏了命名空间:

\begin{cpp}
using namespace mycode;

int main()
{
    foo(); // Implies mycode::foo();
}
\end{cpp}

\begin{myNotic}{NOTE}
main()函数绝不能放在命名空间中，其必须在全局命名空间中。
\end{myNotic}

单个源文件可以包含多个using指令，但不要过度使用这种方式。极端情况下，若声明使用人类已知的所有所以空间，实际上就等于消除了命名空间!若使用包含相同名称的两个名称空间，名称冲突将会继续。知道代码在哪个命名空间中运行也很重要，这样就不会意外地调用错误的函数。

之前已经了解了命名空间的语法，在“Hello, World”程序中我们使用了它，其中println是在std名称空间中定义的名称。可以用using指令写“Hello, World”:

\begin{cpp}
import std;

using namespace std;

int main()
{
    println("Hello, World!");
}
\end{cpp}

\begin{myNotic}{NOTE}
本书中的大多数代码片段都假定std命名空间有一个using指令，C++标准库中的所有内容都可以使用，而不需要用std::来限定。
\end{myNotic}

using声明可用于引用命名空间中的特定项。只想在std命名空间中使用非限定的print，可以使用下面的using声明:

\begin{cpp}
using std::print;
\end{cpp}

后续代码可以在不添加名称空间的情况下引用print，但std命名空间中的其他项，如println，仍然需要显式限定:

\begin{cpp}
using std::print;
print("Hello, ");
std::println("World!");
\end{cpp}

\begin{myWarning}{WARNING}
不要在全局作用域的头文件中放置using指令或using声明;否则，将强制每个包含头文件的源文件执行此操作。可以将其放在较小的作用域中(例如命名空间或类作用域中)，即使在头文件中也是如此。把using指令或声明放在模块接口文件中也完全没问题，只要不导出。我认为模块使接口更容易理解，所以本书完全限定模块接口文件中的所有类型。模块接口文件和从模块导出将在后续章节中进行介绍。
\end{myWarning}

\mySamllsection{嵌套命名空间}

嵌套命名空间是指一个命名空间在另一个命名空间内。每个命名空间由双冒号分隔:

\begin{cpp}
namespace MyLibraries::Networking::FTP {
    /* ... */
}
\end{cpp}

这种紧凑的语法在C++17之前不可用。若是编译器不支持C++17，可以使用如下方法:

\begin{cpp}
namespace MyLibraries {
    namespace Networking {
        namespace FTP {
            /* ... */
        }
    }
}
\end{cpp}

\mySamllsection{命名空间的别名}

命名命名空间别名可用于为另一个命名空间提供一个新的、可能更短的名称:

\begin{cpp}
namespace MyFTP = MyLibraries::Networking::FTP;
\end{cpp}

\mySubsubsection{1.1.3.}{字面量}

字面量用于在代码中编写数字或字符串，C++支持一些标准字面量。整数可以用以下字面值表示(示例表示相同的数字123):

\begin{itemize}
\item
十进制字面量, 123

\item
八进制字面量, 0173 (以0开头)

\item
十六进制字面量, 0x7B (以0x开头)

\item
二进制字面量, 0b1111011 (以0b开头)
\end{itemize}

\begin{myWarning}{WARNING}
除非是八进制字面量，永远不要在数字字面值前面放一个0!
\end{myWarning}

C++中使用字面量的其他例子：

\begin{itemize}
\item
浮点值 (例如 3.14f)

\item
双精度浮点值 (例如 3.14)

\item
十六进制浮点字面值 (例如 0x3.ABCp-10 和 0Xb.cp12l)

\item
单个字符 (例如 'a')

\item
以零结尾的字符数组 (例如 "character array")
\end{itemize}

字面量可以带有后缀，例如3.14f中的f，以强制使用某种类型。本例中，3.14f是float，而3.14是double。

单引号字符可以用作数字字面量中的数字分隔符。例如:

\begin{itemize}
\item
23'456'789

\item
2'34'56'789

\item
0.123'456f
\end{itemize}

仅用空格分隔的多个字符串字面值，可以自动连接成单个字符串。例如:

\begin{cpp}
std::println("Hello, "
             "World!");
\end{cpp}

等价于：

\begin{cpp}
std::println("Hello, World!");
\end{cpp}

也可以自定义字面值，这是第15章中一项高级特性。

\mySubsubsection{1.1.4.}{变量}

C++中，变量几乎可以在代码的任何地方声明，并可以在声明之后的当前块内使用。变量可以在未给定值的情况下声明，这些未初始化的变量通常会有一个随机的值，这个值基于那一刻内存中的内容，因此这也是无数错误的根源。C++中，变量在声明时可以选择初始值。下面的代码展示了两种风格的变量声明，使用了表示整数值的int类型：

\begin{cpp}
int uninitializedInt;
int initializedInt { 7 };
println("{} is a random value", uninitializedInt);
println("{} was assigned as an initial value", initializedInt);
\end{cpp}

\begin{myNotic}{NOTE}
当代码使用未初始化的变量时，大多数编译器都会发出警告或错误。有些编译器会生成在运行时报错的代码。
\end{myNotic}

initializedInt变量可以使用统一的初始化语法进行初始化，也可以使用下面的赋值语法初始化变量:

\begin{cpp}
int initializedInt = 7;
\end{cpp}

统一初始化是在2011年随C++11标准引入的。建议使用统一初始化来代替旧的赋值语法，本书也使用了这种语法。会在后面的章节中更深入地探讨其优点，以及说明推荐使用的原因。

C++中的变量是强类型的，所以总是具有特定的类型。C++提供了一套完整的内置类型，可以直接使用。下表展示了最常见的一些类型：

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}(signed) int signed\end{tabular} &
\begin{tabular}[c]{@{}l@{}}正、负整数;范围取决\\于编译器 \\(通常为4字节)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}int i \{-7\};\\ signed int i \{-6\};\\ signed i \{-5\};\end{tabular} \\ \hline
(signed) short (int) &
\begin{tabular}[c]{@{}l@{}}短整数\\(通常为2字节) \end{tabular}&
\begin{tabular}[c]{@{}l@{}}short s \{13\};\\ short int s \{14\};\\ signed short s \{15\};\\ signed short int s \{16\};\end{tabular} \\ \hline
(signed) long (int) &
\begin{tabular}[c]{@{}l@{}}长整数\\(通常为4字节)\end{tabular} &
long l \{-7L\}; \\ \hline
(signed) long long (int) &
\begin{tabular}[c]{@{}l@{}}超长整型;该范围取决于\\编译器， 但至少与长整数\\相同\\(通常为8字节)\end{tabular} &
long long ll \{14LL\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}unsigned (int)\\ unsigned short (int)\\ unsigned long (int)\\ unsigned long long (int)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}将上述类型限制为\\≥ 0的值\end{tabular} &
\begin{tabular}[c]{@{}l@{}}unsigned int i \{2U\};\\ unsigned j \{5U\};\\ unsigned short s \{23U\};\\ unsigned long l \{54UL\};\\ unsigned long long ll \{140ULL\};\end{tabular} \\ \hline
float &
\begin{tabular}[c]{@{}l@{}}单精度浮点数\end{tabular} &
float f \{7.2f\}; \\ \hline
double &
\begin{tabular}[c]{@{}l@{}}双精度浮点数;\\ 精度至少与float相同\end{tabular} &
double d \{7.2\}; \\ \hline
long double &
\begin{tabular}[c]{@{}l@{}}长双精度浮点数;\\ 精度至少与double相同\end{tabular} &
long double d \{16.98L\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}char unsigned char\\ signed char\end{tabular} &
单个字符 &
char ch \{'m'\}; \\ \hline
\begin{tabular}[c]{@{}l@{}}char8\_t\\ char16\_t\\ char32\_t\end{tabular} &
\begin{tabular}[c]{@{}l@{}}n位UTF-n编码的\\Unicode字符， n可以\\是8、16或32\end{tabular} &
\begin{tabular}[c]{@{}l@{}}char8\_t c8 \{u8'm'\};\\ char16\_t c16 \{u'm'\};\\ char32\_t c32 \{U'm'\};\end{tabular} \\ \hline
wchar\_t &
\begin{tabular}[c]{@{}l@{}}单个宽字符;\\大小取决于编译器\end{tabular} &
wchar\_t w \{L'm'\}; \\ \hline
bool &
\begin{tabular}[c]{@{}l@{}}布尔类型，有两个可能值:\\true或false\end{tabular} &
bool b \{true\}; \\ \hline
\end{longtable}

有符号整数和无符号整数以及char类型的范围如下:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型}                                             & \textbf{有符号}                 & \textbf{无符号}  \\ \hline
\endfirsthead
%
\endhead
%
char                                                      & -128 - 127                     & 0 - 255           \\ \hline
\begin{tabular}[c]{@{}l@{}}2字节的整数\end{tabular} & -32,768 - 32,767               & 0 - 65,535        \\ \hline
\begin{tabular}[c]{@{}l@{}}4字节的整数\end{tabular} & -2,147,483,648 - 2,147,483,647 & 0 - 4,294,967,295 \\ \hline
\begin{tabular}[c]{@{}l@{}}8字节的整数\end{tabular} &
\begin{tabular}[c]{@{}l@{}}-9,223,372,036,854,775,808 -\\ 9,223,372,036,854,775,807\end{tabular} &
0 - 18,446,744,073,709,551,615 \\ \hline
\end{longtable}

char类型与有符号char和无符号char类型相比是一种不同的类型，只用于表示字符。根据编译器的不同，可以有符号，也可以无符号。

浮点类型的范围和精度将在本章的“浮点数”一节中讨论。

与char相关的是，<cstddef>提供了std::byte类型，表示单个字节。C++17之前，使用char或unsigned char来表示字节，但这些类型看起来像是在处理字符。另一方面，std::byte可以清楚地说明意图，即单个字节的内存。字节可以按如下方式初始化:

\begin{cpp}
std::byte b { 42 };
\end{cpp}

\begin{myNotic}{NOTE}
C++不提供基本的字符串类型。但作为标准库的一部分，提供了字符串的标准实现，本章稍后会进行简单说明，详细讨论将在第2章进行。
\end{myNotic}

\mySamllsection{数值范围}

C++提供了一种标准的方法来获取有关数字限制的信息，当前平台上整数的最大可能值。C可以访问常量，例如INT\_MAX。这些在C++中仍然可用，但建议使用<limits>中定义的std::numeric\_limits类模板。类模板将在本书后面讨论，这些细节对于理解如何使用numeric\_limits并不重要。现在，只需要知道它是一个类模板，所以必须在一组尖括号之间指定类型。要获取整数的数值限制，可以使用std::numeric\_limits<int>。参考标准库参考(参见附录B)，了解使用numeric\_limits可以查询哪些类型的信息。

举一些例子：

\begin{cpp}
println("int:");
println("Max int value: {}", numeric_limits<int>::max());
println("Min int value: {}", numeric_limits<int>::min());
println("Lowest int value: {}", numeric_limits<int>::lowest());

println("\ndouble:");
println("Max double value: {}", numeric_limits<double>::max());
println("Min double value: {}", numeric_limits<double>::min());
println("Lowest double value: {}", numeric_limits<double>::lowest());
\end{cpp}

这些代码在我的系统上的输出:

\begin{shell}
int:
Max int value: 2147483647
Min int value: -2147483648
Lowest int value: -2147483648
double:
Max double value: 1.7976931348623157e+308
Min double value: 2.2250738585072014e-308
Lowest double value: -1.7976931348623157e+308
\end{shell}

注意min()和lowest()之间的区别。对于整数，最小值等于最小值。然而，对于浮点类型，最小值是可以表示的最小正值，而最小值是可以表示的最大负值，等于-max()。

\mySamllsection{零初始化}

变量可以用\{0\}初始化为零，也可以用零初始化器\{\}。零初始化将基本整数类型(如char、int等)初始化为零，将基本浮点类型初始化为0.0，将指针类型初始化为nullptr，并使用默认构造函数构造对象(稍后讨论)。

下面是零初始化浮点型和int型的例子:

\begin{cpp}
float myFloat {};
int myInt {};
\end{cpp}

\mySamllsection{类型转换}

变量可以通过强制转换转换为其他类型，可以将float类型强制转换为int类型。C++提供了三种显式更改变量类型的方法。第一个方法是从C语言继承来的，不推荐使用。第二种方法很少使用。第三种方法是最冗长的，但也最干净，推荐使用。

\begin{cpp}
float myFloat { 3.14f };
int i1 { (int)myFloat }; // method 1
int i2 { int(myFloat) }; // method 2
int i3 { static_cast<int>(myFloat) }; // method 3
\end{cpp}

得到的整数将是截断小数部分的浮点数的值，第10章更详细地描述了不同的类型转换方法。某些上下文中，可以自动强制转换或强制转换变量。因为long表示至少具有相同精度的相同类型的数据，short可以自动转换为long:

\begin{cpp}
long someLong { someShort }; // no explicit cast needed
\end{cpp}

自动转换变量时，需要注意潜在的数据丢失。将浮点型转换为int型会丢掉数字的小数部分，若浮点值表示的数字大于可表示的最大整数值，则得到的整数甚至是错误的。若将float赋值给int而不进行显式强制类型转换，大多数编译器将发出警告，甚至报错。若确定左侧类型与右侧类型完全兼容，则可以隐式转换。

\mySamllsection{浮点数}

处理浮点数比处理整型更复杂，使用数量级不同的浮点值进行计算可能会导致错误。此外，计算两个几乎相同的浮点数之间的差会导致精度的损失，许多十进制值不能精确地表示为浮点数。深入讨论使用浮点数的数值问题，以及如何编写数值稳定的浮点算法超出了本书的范围。

有几种特殊的浮点数:

\begin{itemize}
\item
\textbf{正/负无穷大}:表示正无穷大和负无穷大，例如：非零数除以零的结果

\item
\textbf{NaN}: 非数字的缩写，例如：0除以0的结果，数学上未定义的结果
\end{itemize}

要检查给定的浮点数是否不是数字，请使用std::isnan()。要检查无穷大，使用std::isinf()。这两个函数都在<cmath>中定义。

要获得这些特殊的浮点值，请使用numeric\_limits，例如std::numeric\_limits<double>::infinity()。

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{扩展浮点数类型}

正如前面关于变量的部分所提到的，C++提供了以下标准浮点类型:float、double和long double。

C++23引入了以下扩展的浮点类型，这些类型在某些领域已经很流行。对这些类型的支持可选，并不是所有编译器都提供这些类型。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{类型}    & \textbf{描述}                               & \textbf{字面量后缀} \\ \hline
\endfirsthead
%
\endhead
%
std::float16\_t  & IEEE 754标准的16位格式。         & F16 或 f16              \\ \hline
std::float32\_t  & IEEE 754标准的32位格式。          & F32 或 f32              \\ \hline
std::float64\_t  & IEEE 754标准的64位格式。          & F64 或 f64              \\ \hline
std::float128\_t & IEEE 754标准的128位格式。         & F128 或 f128            \\ \hline
std::bfloat16\_t & 脑浮点数，用于某些AI领域。 & BF16 或 bf16            \\ \hline
\end{longtable}

脑浮点数:由谷歌人工智能团队Google Brain开发。用于人工智能处理器，并持最新的NVIDIA GPU。

通常，标准类型float、double和long double就足够了，double应该是默认类型。使用float可能会导致精度损失，损失是否可接受，要具体情况具体分析。

\mySamllsection{浮点类型的范围和精度}

浮点类型具有有限的范围和有限的精度，下表给出了C++支持的所有标准和扩展浮点类型的详细规范。标准类型(float、double和long double)的规范并没有在C++标准中明确规定，标准只要求long double至少具有与double相同的精度，而double至少具有与float相同的精度。对于这三种类型，下表展示了主流编译器常用的值。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|l|l|l|l|}
\hline
\textbf{类型} &
\textbf{名称} &
\textbf{尾数位} &
\textbf{小数位数} &
\textbf{指数位} &
\textbf{最小值} &
\textbf{最大值} \\ \hline
\endfirsthead
%
\endhead
%
float           & \begin{tabular}[c]{@{}l@{}}单精度\end{tabular}   & 24 & 7.22  & 8  & $1.18$x$10^{-38}$   & $3.40$x$10^{38}$   \\ \hline
double          & \begin{tabular}[c]{@{}l@{}}双精度\end{tabular}   & 53 & 15.95 & 11 & $2.23$x$10^{-308}$  & $1.80$x$10^{308}$  \\ \hline
long double     & \begin{tabular}[c]{@{}l@{}}扩展精度\end{tabular} & 64 & 19.27 & 15 & $3.36$x$10^{-4932}$ & $1.19$x$10^{4932}$ \\ \hline
std::float16\_t & \begin{tabular}[c]{@{}l@{}}半精度\end{tabular}     & 11 & 3.31  & 5  & $6.10$x$10^{-5}$    & $65504$       \\ \hline
std::float32\_t & \begin{tabular}[c]{@{}l@{}}单精度\end{tabular}   & 24 & 7.22  & 8  & $1.18$x$10^{-38}$   & $3.40$x$10^{38}$   \\ \hline
std::float64\_t & \begin{tabular}[c]{@{}l@{}}双精度\end{tabular}   & 53 & 15.95 & 11 & $2.23$x$10^{-308}$  & $1.80$x$10^{308}$  \\ \hline
std::float128\_t &
\begin{tabular}[c]{@{}l@{}}四倍精度\end{tabular} &
113 &
34.02 &
15 &
$3.36$x$10^{-4932}$ &
$1.19$x$10^{4932}$ \\ \hline
std::bfloat16\_t &
\begin{tabular}[c]{@{}l@{}}脑浮点\end{tabular} &
8 &
2.41 &
8 &
$1.18$x$10^{-38}$ &
$3.40$x$10^{38}$ \\ \hline
\end{longtable}

\mySubsubsection{1.1.5.}{操作符}

除了改变一个变量，它还有什么用呢?下表显示了C++中常用的操作符，以及使用这些操作符的示例代码。C++中的操作符可以是二进制(对两个表达式进行操作)、一元(对单个表达式进行操作)，甚至三元(对三个表达式进行操作)。C++中只有一种三元操作符，本章后面的“条件操作符”中对其进行了解释。此外，第15章会解释如何自定义类型中，对这些操作符添加支持。

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{操作符} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
= &
\begin{tabular}[c]{@{}l@{}}将右边的值赋给左边表达式的二元操作符\end{tabular} &
\begin{tabular}[c]{@{}l@{}}int i;\\ i = 3;\\ int j;\\ j = i;\end{tabular} \\ \hline
! &
\begin{tabular}[c]{@{}l@{}}用于补充表达式的真/假(非0/0)状态的一元操作符\end{tabular} &
\begin{tabular}[c]{@{}l@{}}bool b \{!true\};\\ bool b2 \{!b\};\end{tabular} \\ \hline
+ &
用于加法的二进制操作符 &
\begin{tabular}[c]{@{}l@{}}int i \{3 + 2\};\\ int j \{i + 5\};\\ int k \{i + j\};\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}-\\ *\\ /\end{tabular} &
用于减法、乘法和除法的二进制操作符 &
\begin{tabular}[c]{@{}l@{}}int i \{5 – 1\};\\ int j \{5 * 2\};\\ int k \{j / i\};\end{tabular} \\ \hline
\% &
\begin{tabular}[c]{@{}l@{}}除法运算余数的二进制操作符，也称为取模或取模算子。\\ 例如: 5\%2=1\end{tabular} &
int rem \{5 \% 2\}; \\ \hline
++ &
\begin{tabular}[c]{@{}l@{}}一元操作符，将表达式加1。\\ 若操作符出现在表达式之后或自增后，则表达式的结果\\是未自增的值若操作符出现在表达式之前，或者在\\递增前，表达式的结果就是新值\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i++;\\ ++i;\end{tabular} \\ \hline
-- &
一元操作符，将表达式减1。 &
\begin{tabular}[c]{@{}l@{}}i--;\\ --i;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}+=\\ -=\\ *=\\ /+\\ \%=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}简写语法:\\ i = i + (j);\\ i = i - (j);\\ i = i * (j);\\ i = i / (j);\\ i = i \% (j);\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i += j;\\ i -= j;\\ i *= j;\\ i /= j;\\ i \%= j;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\&\\ \&=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取变量的位表达式，并与另一个表达式按位执行与运算。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = j \& k;\\ j \&= k;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}|\\ |=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取变量的位表达式，并对另一个表达式执行位或运算。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = j | k;\\ j |= k;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\textless{}\textless\\ \textgreater{}\textgreater\\ \textless{}\textless{}=\\ \textgreater{}\textgreater{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}获取表达式的原始位，并将每个位向左\\ (\textless{}\textless{})或向右(\textgreater{}\textgreater{})移动，指定的位数。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = i \textless{}\textless 1;\\ i = i \textgreater{}\textgreater 4;\\ i \textless{}\textless{}= 1;\\ i \textgreater{}\textgreater{}= 4;\end{tabular} \\ \hline
\begin{tabular}[c]{@{}l@{}}\textasciicircum\\ \textasciicircum{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}对两个表达式执行位异或操作，也称为异或操作。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}i = i \textasciicircum j;\\ i \textasciicircum{}= j;\end{tabular} \\ \hline
\end{longtable}

op=形式的操作符，例如+=，称为复合赋值操作符。

当二元操作符应用于两个不同类型的操作数时，编译器会插入隐式转换。应用该操作符之前，将其中一个操作数转换为另一个操作数。还可以使用static\_cast()显式将一种类型转换为另一种类型。

对于隐式转换，编译器有一定的规则来决定将哪个类型转换为另一个类型。例如，对于具有小整数类型和大整数类型的二进制操作，较小的类型将转换为较大的类型。但结果可能并不像期望的那样，所以建议谨慎使用隐式转换。使用显式转换，以确保编译器按期望工作。

下面的代码段显示了最常见的变量类型和操作符。还展示了显式转换，并解释了为什么需要转换。若不确定变量和操作符是如何工作的，请尝试预测这个程序的输出将是什么，然后运行来确认答案。

\begin{cpp}
int someInteger { 256 };
short someShort;
long someLong;
float someFloat;
double someDouble;

someInteger++;
someInteger *= 2;
// Conversion from larger integer type to smaller integer type
// can cause a warning or error, hence static_cast() is required.
someShort = static_cast<short>(someInteger);
someLong = someShort * 10000;
someFloat = someLong + 0.785f;
// To make sure the division is performed with double precision,
// someFloat is explicitly converted to double first.
someDouble = static_cast<double>(someFloat) / 100000;
println("{}", someDouble);
\end{cpp}

C++编译器有一个表达式计算的顺序。若有一个包含许多操作符的复杂表达式，则执行顺序可能不明显。出于这个原因，最好将一个复杂的表达式分解成几个较小的表达式，或者通过使用括号显式地对子表达式进行分组。除非知道操作符的准确求值顺序，否则下面这行代码的计算顺序可能会令人困惑:

\begin{cpp}
int i { 34 + 8 * 2 + 21 / 7 % 2 };
\end{cpp}

添加括号可以明确哪些操作先发生:

\begin{cpp}
int i { 34 + (8 * 2) + ( (21 / 7) % 2 ) };
\end{cpp}

这两种方法是相等的，最后i等于51。若假设C++从左到右计算表达式，则的答案将是1。C++首先计算/，*和\%(按从左到右的顺序)，然后是加法和减法，然后是位操作符。括号可以显式地告诉编译器应该首先计算某个操作。

操作符的求值顺序由它们的优先级表示，优先级高的操作符在优先级低的操作符之前执行。下面的列表显示了上表中操作符的优先级，列表中较高的操作符具有较高的优先级，因此在列表中较低的操作符之前执行。

\begin{itemize}
\item
++ \enspace −{}− (后置)

\item
! \enspace ++ \enspace −{}− (前置)

\item
* \enspace / \enspace \%

\item
+ \enspace −

\item
<{}< \enspace >{}>

\item
\&

\item
\textasciicircum

\item
|

\item
= \enspace += \enspace -= \enspace *= \enspace /= \enspace \%= \enspace \&= \enspace |= \enspace \textasciicircum= \enspace <{}<= \enspace >{}>=

\end{itemize}

这只是一些常用的C++操作符。第15章给出了所有可用操作符的完整概述，包括优先级。

\mySubsubsection{1.1.6.}{枚举}

整数实际上表示较大的值集合中的一个值——整数序列。枚举是允许自定义序列的类型，这样就可以用该序列中的值声明变量。在国际象棋程序中，可以将每个棋子表示为int，并用常量表示棋子类型。表示类型的整数标记为const，表明永远不会改变。

\begin{cpp}
const int PieceTypeKing { 0 };
const int PieceTypeQueen { 1 };
const int PieceTypeRook { 2 };
const int PieceTypePawn { 3 };
//etc.
int myPiece { PieceTypeKing };
\end{cpp}

这种表示可能会变得危险。由于piece只是一个int类型，若另一个开发者添加代码来增加piece的值，会发生什么?加1，国王就变成了王后，这真的没有意义。更糟糕的是，有人可能会给一个片段一个-1的值，而这个值没有对应的常数。

强类型枚举通过严格定义变量的值范围来解决这些问题。下面的代码声明了一个新类型PieceType，有四个可能的值，称为枚举数，代表四个棋子:

\begin{cpp}
enum class PieceType { King, Queen, Rook, Pawn };
\end{cpp}

新类型可以这样使用:

\begin{cpp}
PieceType piece { PieceType::King };
\end{cpp}

枚举只是一个整数值，King、Queen、Rook和Pawn的基本值分别为0、1、2和3。可以自己指定枚举数的整数值:

\begin{cpp}
enum class PieceType
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};
\end{cpp}

若没有给枚举数赋值，编译器会自动给它赋一个上一个枚举数加1的值。若不给第一个枚举数赋值，编译器将给它赋值0。这个例子中，King的整数值是1，Queen的值是编译器赋值的2，Rook的值是10，Pawn的值是编译器自动赋值的11。

尽管枚举数在内部由整数值表示，但不会自动转换为整数，所以以下操作是非法的:

\begin{cpp}
int underlyingValue { piece };
\end{cpp}

\CXXTwentythreeLogo{-40}{-35}

C++23开始，可以使用std::to\_underlying()。例如:

\begin{cpp}
int underlyingValue { to_underlying(piece) };
\end{cpp}

默认情况下，枚举数的基础类型是整数，但也可以这样修改:

\begin{cpp}
enum class PieceType : unsigned long
{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};
\end{cpp}

对于枚举类，枚举数名称不会自动导出到封闭作用域，所以不会与父作用域中已经定义的其他名称冲突，从而不同的强类型枚举可以具有相同名称的枚举数。下面两个枚举完全合法:

\begin{cpp}
enum class State { Unknown, Started, Finished };
enum class Error { None, BadInput, DiskFull, Unknown };
\end{cpp}

这样做的好处是，可以为枚举器提供简短的名称，用Unknown代替UnknownState和UnknownError。但必须完全限定枚举值，或者使用using enum或using声明。下面是using enum声明的一个例子:

\begin{cpp}
using enum PieceType;
PieceType piece { King };
\end{cpp}

若希望避免完全限定特定枚举数，可以使用using声明。下面的代码段中，King可以在没有完全限定的情况下使用，但其他枚举数仍然需要完全限定:

\begin{cpp}
using PieceType::King;
PieceType piece { King };
piece = PieceType::Queen;
\end{cpp}

\begin{myWarning}{WARNING}
尽管C++允许您避免完全限定的枚举，但建议谨慎使用该特性。至少要缩小using enum或using声明的作用域，因为若这个作用域太大，就有可能会引入名称冲突。本章后面关于switch语句的部分，展示了using enum声明的适当用法。
\end{myWarning}

\mySamllsection{旧式枚举}

新代码应该使用强类型枚举。但在历史代码库中，可能会看到旧式枚举，也称为无作用域枚举:enum，而非enum类。下面是之前定义为旧式枚举的PieceType:

\begin{cpp}
enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn };
\end{cpp}

旧式枚举的枚举数导出到封闭作用域。所以在父作用域中，可以使用枚举数的名称，而不完全限定它们，例如:

\begin{cpp}
PieceType myPiece { PieceTypeQueen };
\end{cpp}

当然，可能与父作用域中已经定义的其他名称冲突，从而导致编译错误。这里有一个例子:

\begin{cpp}
bool ok { false };
enum Status { error, ok };
\end{cpp}

这段代码片段无法编译，因为ok定义为一个布尔变量，之后又将相同的名称用作枚举数的名称。Visual C++ 2022会出现以下错误:

\begin{shell}
error C2365: 'ok': redefinition; previous definition was 'data variable'
\end{shell}

应该确保这种旧式枚举具有具有唯一名称的枚举数，例如PieceTypeQueen，而不是简单的Queen。

这些旧式枚举不是强类型，所以类型不安全。它们可解释为整数，所以会无意中比较来自完全不同枚举的枚举数，或者将错误的枚举数传递给函数。

\begin{myWarning}{WARNING}
使用强类型枚举类枚举，而不是旧式的、无作用域的、类型不安全的枚举类型。
\end{myWarning}

\mySubsubsection{1.1.7.}{结构体}

结构体将一个或多个现有类型封装成一个新的类型，其经典示例是数据库。构建一个人事系统来跟踪员工信息，可能希望存储每个员工的姓名首字母、姓氏首字母、员工编号和薪资。以下employee.cppm模块接口文件中展示了一个包含所有这些信息的结构体，这是目前编写的第一个模块。模块接口文件通常具有.cppm扩展名。模块接口文件的第一行是一个模块声明，表明这个文件正在定义一个名为employee的模块。模块需要明确声明它导出了什么，即当这个模块在其他地方导入时，哪些内容可见。通过在结构体前加上export关键字，可以从模块中导出一个类型。

\begin{cpp}
export module employee;

export struct Employee {
    char firstInitial;
    char lastInitial;
    int employeeNumber;
    int salary;
};
\end{cpp}

使用类型Employee声明的变量内置了所有这些字段，结构体的各个字段可以通过使用操作符来访问。下面的示例创建然后输出一个员工的记录，与导入标准命名模块std一样，导入自定义模块也不使用尖括号。

\begin{cpp}
import std;
import employee; // Import our employee module

using namespace std;

int main()
{
    // Create and populate an employee.
    Employee anEmployee;
    anEmployee.firstInitial = 'J';
    anEmployee.lastInitial = 'D';
    anEmployee.employeeNumber = 42;
    anEmployee.salary = 80000;
    // Output the values of an employee.
    println("Employee: {}{}", anEmployee.firstInitial,
        anEmployee.lastInitial);
    println("Number: {}", anEmployee.employeeNumber);
    println("Salary: ${}", anEmployee.salary);
}
\end{cpp}

\mySubsubsection{1.1.8.}{条件语句}

条件语句可以根据某个条件是否为true来执行代码，C++中有两种主要的条件语句：if/else语句和switch语句。

\mySamllsection{if/else}

最常见的条件语句是if语句，可以伴随一个else。若if语句内部给出的条件为true，则执行该行或代码块；否则，继续执行当前if语句的else情况（若存在），或者执行条件语句之后的代码。以下代码展示了一个级联if语句，if语句有一个else语句，而这个else语句又有一个if语句，依此类推：

\begin{cpp}
if (i > 4) {
    // Do something.
} else if (i > 2) {
    // Do something else.
} else {
    // Do something else.
}
\end{cpp}

if语句括号内的表达式必须是布尔值，或计算结果为布尔值。值为0的计算结果为false，而非零值的计算结果为true，if(0)等同于if(false)。后面为逻辑操作符提供了一种方法，用于计算表达式以产生true或false。

\mySamllsection{if语句的初始化式}

C++允许在if语句中使用以下语法包含一个初始化表达式：

\begin{cpp}
if (<initializer>; <conditional_expression>) {
    <if_body>
} else if (<else_if_expression>) {
    <else_if_body>
} else {
    <else_body>
}
\end{cpp}

<initializer>中引入的变量仅在<conditional\_expression>、<if\_body>、所有<else\_if\_expression>和<else\_if\_body>，以及<else\_body>中可用。这样的变量在if语句外部不可用。

这里有一个例子:

\begin{cpp}
if (Employee employee { getEmployee() }; employee.salary > 1000) { ... }
\end{cpp}

初始化器通过调用getEmployee()函数来获取一个员工，条件检查检索到的员工的薪资是否超过1000，只有超过了才会执行if语句的主体。本书将在后续提供更具体的例子。

\mySamllsection{switch}

switch语句是基于表达式值执行操作的替代语法。在C++中，switch语句的表达式必须是整型、可转换为整型的类型、枚举或强类型枚举，并且必须与常量进行比较。每个常量值代表一个“case”。若表达式与某个case匹配，就会执行后续的代码，直到遇到break语句。还可以提供一个default，若其他case都不匹配，就会执行default。以下伪代码展示了switch语句的常见用法：

\begin{cpp}
switch (menuItem) {
    case OpenMenuItem:
        // Code to open a file
        break;
    case SaveMenuItem:
        // Code to save a file
        break;
    default:
        // Code to give an error message
        break;
}
\end{cpp}

switch语句可以转换为if/else语句，前面的switch语句可以转换为：

\begin{cpp}
if (menuItem == OpenMenuItem) {
    // Code to open a file
} else if (menuItem == SaveMenuItem) {
    // Code to save a file
} else {
    // Code to give an error message
}
\end{cpp}

switch语句通常根据表达式的多个特定值使用，而不是对表达式进行测试。这种情况下，switch语句避免了级联的if/else语句。若只需要检查一个值，使用if或if/else语句就可以。

当找到与switch条件匹配的case表达式，就会执行跟随其后的所有语句，直到遇到break语句。即使遇到另一个case表达式也会继续，这称为“fallthrough”（穿透）。下面的例子中，对于Mode::Standard和Default，执行的是同一组语句。若mode是Custom，则value首先从42改为84，之后Standard和Default的语句也会执行。换句话说，Custom会穿透执行，直到最终遇到一个break语句或switch语句的末尾。这段代码还展示了使用适当作用域的using enum声明的好例子，避免了在不同case标签上写Mode::Custom, Mode::Standard和Mode::Default的必要。

\begin{cpp}
enum class Mode { Default, Custom, Standard };

int value { 42 };
Mode mode { /* ... */ };
switch (mode) {
    using enum Mode;

    case Custom:
        value = 84;
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

穿透可能会导致错误，不小心忘记了一个break语句。一些编译器会在switch语句中检测穿透情况，除非case为空，否则会给出一个警告。之前的例子中，没有编译器会警告Standard案例穿透到Default案例，但是对于Custom案例的穿透，编译器可能会给出警告。为了避免这个警告，并让读者和编译器清楚穿透是有意的，可以使用[[fallthrough]]：

\begin{cpp}
switch (mode) {
    using enum Mode;

    case Custom:
        value = 84;
        [[fallthrough]];
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

通常，case表达式后面的语句的大括号可选，但在定义变量时，是必要的：

\begin{cpp}
switch (mode) {
    using enum Mode;
    case Custom:
        {
            int someVariable { 42 };
            value = someVariable * 2;
            [[fallthrough]];
        }
    case Standard:
    case Default:
        // Do something with value ...
        break;
}
\end{cpp}

当使用switch语句处理枚举时，若没有为所有的枚举器处理所有不同的情况，大多数编译器会发出警告，无论是通过为每个枚举器显式编写case，还是通过仅为选择的一部分枚举器编写case，并带有一个default。建议在处理枚举的switch语句中不要包含default，应该显式地列出所有的枚举器。以后向枚举中添加更多的枚举值，会使代码避免出错。若忘记将新的枚举值添加到特定的switch语句中，编译器将发出警告，而不是使用default处理新枚举值。

\mySamllsection{switch语句的初始化式}

像if语句一样，可以在switch语句中使用初始化式。语法如下：

\begin{cpp}
switch (<initializer>; <expression>) { <body> }
\end{cpp}

<initializer>中引入的变量仅在<expression>和<body>中可用，其在switch语句外部不可用。

\mySubsubsection{1.1.9.}{条件操作符}

C++有一个接受三个参数的操作符，称为三元操作符。可用作一种简短的条件表达式，即“如果[某事]为真，则[执行动作]，否则[执行其他动作]”。条件操作符由?和:表示。以下代码在变量i大于2时输出“yes”，否则输出“no”：

\begin{cpp}
println("{}", (i > 2) ? "yes" : "no");
\end{cpp}

i > 2周围的大括号是可选的，等价与:

\begin{cpp}
println("{}", i > 2 ? "yes" : "no");
\end{cpp}

其优势在于它是一个表达式。前面的例子中，条件操作符可用在执行输出的代码中。这种语法方便在，将问号前面的语句当作一个真正的问题。"例如，i大于2吗？若是，结果是'yes'；若不是，结果是'no'。"

\mySubsubsection{1.1.10.}{逻辑操作符}

已经看到了一个逻辑操作符，但没有正式的定义，操作符>会比较两个值。若左边的值大于右边的值，结果为真。所有逻辑操作符都遵循这种模式——其结果是true或false。

下表给出了常见的逻辑求值操作符:

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}{|l|l|l|}
\hline
\textbf{操作符} &
\textbf{描述} &
\textbf{用法} \\ \hline
\endfirsthead
%
\endhead
%
\begin{tabular}[c]{@{}l@{}}\textless\\ \textless{}=\\ \textgreater\\ \textgreater{}=\end{tabular} &
\begin{tabular}[c]{@{}l@{}}确定左边是否小于、小于或\\等于、大于或大于或等于右边。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i \textless 0) \{\\   print("i is negative");\\ \}\end{tabular} \\ \hline
== &
\begin{tabular}[c]{@{}l@{}}确定左边是否等于右边。\\不要将它与=(赋值)操作符混淆!\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i == 3) \{\\   print("i is 3");\\ \}\end{tabular} \\ \hline
!= &
\begin{tabular}[c]{@{}l@{}}不是等号。若左边不等于右\\边，这个语句的结果为true。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (i != 3) \{\\   print("i is not 3");\\ \}\end{tabular} \\ \hline
\textless{}=\textgreater{} &
\begin{tabular}[c]{@{}l@{}}三向比较操作符，也称为太\\空飞船操作符。\\ 下一节将更详细地解释。\end{tabular} &
result = i \textless{}=\textgreater 0; \\ \hline
! &
\begin{tabular}[c]{@{}l@{}}逻辑否。这是布尔表达式\\true/false状态的补充，\\ 是一元算子。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (!bool1) \{\\   print("bool1 is false");\\ \}\end{tabular} \\ \hline
\&\& &
\begin{tabular}[c]{@{}l@{}}逻辑与。若表达式的两个\\部分都为true，则结果为true。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (bool1 \&\& bool2) \{\\   print("both are true");\\ \}\end{tabular} \\ \hline
|| &
\begin{tabular}[c]{@{}l@{}}逻辑或。若表达式的任何\\一部分为true，则结果为true。\end{tabular} &
\begin{tabular}[c]{@{}l@{}}if (bool1 || bool2) \{\\   print("at least one is true");\\ \}\end{tabular} \\ \hline
\end{longtable}

C++中，逻辑表达式时使用短路逻辑，当最终结果确定，表达式的其余部分将不会计算。若对几个布尔表达式执行逻辑或操作，如以下代码所示，当发现其中一个为true，结果就已知为true，其余的部分就不会进行检查了。

\begin{cpp}
bool result { bool1 || bool2 || (i > 7) || (27 / 13 % i + 1) < 2 };
\end{cpp}

这个例子中，若bool1为true，则整个表达式必须为true，因此其他部分不会计算。语言避免了你的代码做不必要的工作，但若后续的子表达式以某种方式影响程序的状态（例如，通过调用一个单独的函数），这可能会成为难以发现的错误的来源。

下面的代码显示了一个使用\&\&的语句，因为0的计算结果总是为false，所以该语句在第二项之后短路:

\begin{cpp}
bool result { bool1 && 0 && (i > 7) && !done };
\end{cpp}

短路可以带来性能上的好处，可以将资源消耗较少的测试放在前面，这样当逻辑短路时，更昂贵的测试不会执行到。指针的上下文中，可以避免在指针无效时执行表达式的某些部分。

\mySubsubsection{1.1.11.}{三向比较操作符}

三向比较操作符可以用来确定两个值的顺序，也称为太空船操作符，因为其符号<=>像一艘太空船。使用单个表达式，可以了解一个值是等于、小于还是大于另一个值。因为它必须返回的不仅是false或true，所以不能返回布尔类型，但它返回一个在std命名空间中<compare>定义的类枚举类型。若操作数是整型，结果是一个强序，可以是以下之一：

\begin{itemize}
\item
strong\_ordering::less: 第一个操作数小于第二个

\item
strong\_ordering::greater: 第一个操作数大于第二个

\item
strong\_ordering::equal: 第一个操作数等于第二个
\end{itemize}

用法:

\begin{cpp}
int i { 11 };
strong_ordering result { i <=> 0 };
if (result == strong_ordering::less) { println("less"); }
if (result == strong_ordering::greater) { println("greater"); }
if (result == strong_ordering::equal) { println("equal"); }
\end{cpp}

某些类型没有顺序关系。非数（NaN）浮点值永远不会等于、小于或大于浮点数，所以这种比较结果是一个偏序关系：

\begin{itemize}
\item
partial\_ordering::less: 第一个操作数小于第二个

\item
partial\_ordering::greater: 第一个操作数大于第二个

\item
partial\_ordering::equivalent: 第一个操作数相当于第二个操作数，!(a<b) \&\& !(b<a);例如，-0.0等于+0.0，但它们其实不相等

\item
partial\_ordering::unordered: 若一个或两个操作数都不是数字
\end{itemize}

若需要浮点值的强排序，比较的两个数是数字，可以使用std::strong\_order()，会产生一个std::strong\_ordering结果。

还有一种弱序关系，可以用来为自定义类型实现三向比较的排序类型。弱序关系中，所有值都有序，即没有无序结果，但排序不是强序，所以可能存在实际不等，但使用时等价的值。一个例子是对字符串进行不区分大小写的比较，字符串“Hello World”和“hello world”显然不相等，但它们等价。以下是弱序关系的不同结果：

\begin{itemize}
\item
weak\_ordering::less: 第一个操作数小于第二个

\item
weak\_ordering::greater: 第一个操作数大于第二个

\item
weak\_ordering::equivalent: 第一个操作数等同于第二个
\end{itemize}

三种不同类型的排序支持某些隐式转换。强排序（strong\_ordering）可以隐式转换为偏排序（partial\_ordering）或弱排序（weak\_ordering），弱排序（weak\_ordering）可以隐式转换为偏排序（partial\_ordering）。

对于基本类型来说，使用三向比较操作符相比于直接使用 ==、<和>操作符进行单个比较，并没有带来太多优势。但当涉及到比较成本较高的对象时，三向比较操作符就变得非常有用了。使用三向比较操作符，这类对象可以通过单个操作符进行排序，而不需要调用两个单独的比较操作符，从而进行两次昂贵的比较。

最后，<compare>提供了命名比较函数来解释排序的结果。这些函数是std::is\_eq(), is\_neq(), is\_lt(), is\_lteq(), is\_gt()和 is\_gteq()，如果排序代表==，!=，<，<=，>或>=，则分别返回true，否则返回false。下面是一个例子：

\begin{cpp}
int i { 11 };
strong_ordering result { i <=> 0 };
if (is_lt(result)) { println("less"); }
if (is_gt(result)) { println("greater"); }
if (is_eq(result)) { println("equal"); }
\end{cpp}

\mySubsubsection{1.1.12.}{函数}

具有一定规模的程序来说，不可能将所有代码放在main()函数内部。为了使程序更容易理解，需要将代码分解成函数。

C++中，需要声明一个函数，以便其他代码可以使用它。若函数只在特定的文件内部使用，通常需要在那个源文件中声明和定义函数。若函数要在其他模块或文件使用，需要从模块接口文件中导出函数的声明，而函数的定义可以位于相同的模块接口文件中，或者在一个模块实现文件中（后面会讨论）。

\begin{myNotic}{NOTE}
函数声明称为函数原型或函数头文件，表示函数如何访问。函数签名的术语用于指代函数名，及其参数列表的组合，但不包括返回类型。
\end{myNotic}

函数声明在下面的代码中显示。这个例子有一个返回类型为void，表示该函数不向调用者提供结果。调用者必须为函数提供两个参数以供其使用——一个整数和一个字符。

\begin{cpp}
void myFunction(int i, char c);
\end{cpp}

若没有与这个函数声明相匹配的实际定义，使用该函数的代码将会调用不存在的代码，编译过程的链接阶段将会失败。以下的定义打印出两个参数的值：

\begin{cpp}
void myFunction(int i, char c)
{
    println("The value of i is {}.", i);
    println("The value of c is {}.", c);
}
\end{cpp}

程序的其它地方，可以调用myFunction()并为两个参数传递参数。这里展示了一些函数调用：

\begin{cpp}
int someInt { 6 };
char someChar { 'c' };
myFunction(8, 'a');
myFunction(someInt, 'b');
myFunction(5, someChar);
\end{cpp}

\begin{myNotic}{NOTE}
C++与C不同，一个不接受参数的函数只需要一个空的参数列表。没有必要使用void来指示无参数。但当没有值返回时，仍然需要使用void。
\end{myNotic}

C++函数也可以向调用者返回一个值。以下函数将两个数字相加并返回结果：

\begin{cpp}
int addNumbers(int number1, int number2)
{
    return number1 + number2;
}
\end{cpp}

这个函数可以这样调用:

\begin{cpp}
int sum { addNumbers(5, 3) };
\end{cpp}

\mySamllsection{函数返回类型推导}

可以要求编译器自动找出函数的返回类型，只需将auto指定为返回类型即可。

\begin{cpp}
auto addNumbers(int number1, int number2)
{
    return number1 + number2;
}
\end{cpp}

编译器根据函数体中用于返回语句的表达式来推断返回类型。编译器永远不会插入隐式转换来推断函数的返回类型，所以可以有多个返回语句，但都必须都解析为完全相同的类型。这样的函数可以是递归调用（调用自身）的，但函数中的第一个返回语句必须是非递归调用。

\mySamllsection{获取当前函数名}

每个函数都有一个局部预定义变量\_\_func\_\_包含当前函数的名称，这个变量很可能会用于日志记录。

\begin{cpp}
int addNumbers(int number1, int number2)
{
    println("Entering function {}", __func__);
    return number1 + number2;
}
\end{cpp}

\mySamllsection{函数重载}

重载函数可提供多个具有相同名称但具有不同参数集的函数，调用函数时可以忽略返回值，所以只指定不同的返回类型完全不够，而参数的数量和/或类型必须不同。

若希望提供处理整数和双精度的addNumbers()。若没有重载，将需要为函数使用唯一名称，例如:

\begin{cpp}
int addNumbersInts(int a, int b) { return a + b; }
double addNumbersDoubles(double a, double b) { return a + b; }
\end{cpp}

有了函数重载，就不需要为函数的不同版本取不同的名字。下面的代码片段定义了两个名为addNumbers()的函数，一个为整型定义，另一个为双精度定义:

\begin{cpp}
int addNumbers(int a, int b) { return a + b; }
double addNumbers(double a, double b) { return a + b; }
\end{cpp}

当调用addNumbers()时，编译器会根据提供的参数自动选择正确的重载函数，这个过程称为重载解析。

\begin{cpp}
println("{}", addNumbers(1, 2)); // Calls the integer version
println("{}", addNumbers(1.11, 2.22)); // Calls the double version
\end{cpp}

\mySubsubsection{1.1.13.}{属性}

属性是一种向源代码中添加可选和/或特定于供应商的信息的机制。C++标准化属性之前，供应商决定如何指定这些信息。例如\_\_attribute\_\_、\_\_declspec等。从C++11开始，通过使用双方括号语法[[attribute]]，对属性有了标准化的支持。

之前的内容使用了[[fallthrough]]属性，是为了防止在switch case语句中故意出现穿透时编译器发出警告。C++标准定义了很多的标准属性：

\mySamllsection{[[nodiscard]]}

[[nodiscard]]属性可用于返回值的函数。若调用函数没有使用该函数的返回值，编译器将发出警告。下面是一个例子:

\begin{cpp}
[[nodiscard]] int func() { return 42; }

int main()
{
    func();
}
\end{cpp}

编译器会发出类似的警告:

\begin{shell}
warning C4834: discarding return value of function with 'nodiscard' attribute
\end{shell}

这个特性可以用于返回错误代码的函数。通过向这些函数添加[[nodiscard]]属性，就不能忽略返回的错误码。

[[nodiscard]]属性可用于类、结构、函数和枚举。将属性应用于整个类的一个示例是，当有一个表示错误条件的类时。通过将[[nodiscard]]应用于这样的类，编译器将对每个返回此类错误条件的函数调用发出警告，并且调用者没有对其进行任何操作。

可以以字符串的形式为[[nodiscard]]属性提供原因。若函数的调用者忽略返回值，则编译器会在生成的警告消息中显示此原因。下面是一个例子:

\begin{cpp}
[[nodiscard("Some explanation")]] int func();
\end{cpp}

\mySamllsection{[[maybe\_unused]]}

[[maybe\_unused]]属性可以用来抑制编译器在某些代码未使用时发出警告:

\begin{cpp}
int func(int param1, int param2)
{
    return 42;
}
\end{cpp}

若编译器警告级别设置得足够高，该函数定义将导致两个编译器警告。例如，Microsoft Visual C++给出了警告:

\begin{shell}
warning C4100: 'param2': unreferenced formal parameter
warning C4100: 'param1': unreferenced formal parameter
\end{shell}

通过使用[[maybe\_unused]]属性，可以抑制这样的警告:

\begin{cpp}
int func(int param1, [[maybe_unused]] int param2)
{
    return 42;
}
\end{cpp}

第二个参数标记为抑制其警告的属性，编译器现在只对param1发出警告:

\begin{shell}
warning C4100: 'param1': unreferenced formal parameter
\end{shell}

[[maybe\_unused]]属性可用于类、结构体、非静态数据成员、联合、类型定义、类型别名、变量、函数、枚举和枚举值。

\mySamllsection{[[noreturn]]}

向函数添加[[noreturn]]属性意味着不会将控制权返回给调用者，该函数要么导致某种终止(进程终止或线程终止)，要么抛出异常。本章后面将讨论异常。有了这个属性，编译器可以避免给出某些警告或错误。下面是一个例子:

\begin{cpp}
import std;
using namespace std;

[[noreturn]] void forceProgramTermination()
{
    exit(1); // Defined in <cstdlib>
}

bool isDongleAvailable()
{
    bool isAvailable { false };
    // Check whether a licensing dongle is available...
    return isAvailable;
}

bool isFeatureLicensed(int featureId)
{
    if (!isDongleAvailable()) {
        // No licensing dongle found, abort program execution!
        forceProgramTermination();
    } else {
        // Dongle available, perform license check of the given feature...
        bool isLicensed { featureId == 42 };
        return isLicensed;
    }
}

int main()
{
    bool isLicensed { isFeatureLicensed(42) };
    println("{}", isLicensed);
}
\end{cpp}

此代码段编译良好，没有警告或错误。若删除[[noreturn]]属性，编译器会生成以下警告(Visual C++的输出):

\begin{shell}
warning C4715: 'isFeatureLicensed': not all control paths return a value
\end{shell}

\mySamllsection{[[deprecated]]}

[[deprecated]]可以用来标记已弃用的东西，但不鼓励使用。该属性接受一个可选参数，该参数可用于解释弃用的原因:

\begin{cpp}
[[deprecated("Unsafe function, please use xyz")]] void func();
\end{cpp}

若使用这个已弃用的函数，将得到编译错误或警告。GCC会给出以下警告:

\begin{shell}
warning: 'void func()' is deprecated: Unsafe function, please use xyz
\end{shell}

\mySamllsection{[[likely]] 和 [[unlikely]]}

属性[[likely]]和[[unlikely]]可以用来帮助编译器优化代码，可以使用这些属性来标记if语句的分支，并根据执行分支的可能性来切换语句，但很少需要这些属性。现在的编译器和硬件都有强大的分支预测功能，可以自行解决问题，但在某些情况下，比如性能关键的代码，编译器可能需要帮助。语法如下:

\begin{cpp}
int value { /* ... */ };
if (value > 11) [[unlikely]] { /* Do something ... */ }
else { /* Do something else ... */ }

switch (value)
{
    [[likely]] case 1:
        // Do something ...
        break;
    case 2:
        // Do something ...
        break;
    [[unlikely]] case 12:
        // Do something ...
        break;
}
\end{cpp}

\CXXTwentythreeLogo{-40}{-50}

\mySamllsection{[[assume]]}

[[assume]]属性允许编译器假设某些表达式为true，编译器可以使用这样的假设来更好地优化代码。作为一个例子，来看看下面的函数:

\begin{cpp}
int divideBy32(int x)
{
    return x / 32;
}
\end{cpp}

该函数接受一个有符号整数，编译器必须生成代码以确保除法对正数和负数都有效。若确定x永远不会是负数，并且由于某些原因不能使x的类型为unsigned，可以添加如下假设:

\begin{cpp}
int divideBy32(int x)
{
    [[assume(x >= 0)]];
    return x / 32;
}
\end{cpp}

有了这个假设，编译器就可以省略处理负数的代码，并将除法优化为一条指令，即简单的向右移5位。

\mySubsubsection{1.1.14.}{C风格的数组}

\begin{myWarning}{WARNING}
本节介绍了C风格数组，可能会在历史代码中看到它们。C++中，最好避免使用C风格的数组，而是使用标准库功能，例如std::array和vector，这些将在下面的两节中讨论。
\end{myWarning}

数组持有一系列值，所有值类型相同，每个值都可以通过在数组中的位置来访问。C++声明数组时，必须提供数组的大小。不能使用变量作为大小——必须是常量，或者是一个常量表达式（constexpr）。下面的代码展示了声明一个包含三个整数的数组，接着是三行代码用于将元素初始化为0：

\begin{cpp}
int myArray[3];
myArray[0] = 0;
myArray[1] = 0;
myArray[2] = 0;
\end{cpp}

\begin{myWarning}{WARNING}
C++数组的第一个元素始终位于位置0，而不是位置1！数组的最后一个位置的索引是数组大小减1！
\end{myWarning}

本章后面“循环”部分讨论了如何使用循环来初始化数组的每个元素，除了使用循环或之前的初始化机制，还可以使用以下单行代码来完成零初始化：

\begin{cpp}
int myArray[3] = { 0 };
\end{cpp}

可以省略0：

\begin{cpp}
int myArray[3] = {};
\end{cpp}

还可以省略等号:

\begin{cpp}
int myArray[3] {};
\end{cpp}

可以使用初始化列表初始化数组，编译器会自动计算数组的大小:

\begin{cpp}
int myArray[] { 1, 2, 3, 4 }; // The compiler creates an array of 4 elements
\end{cpp}

若指定了数组的大小，并且初始化列表中的元素少于给定的大小，则剩余的元素将设置为0。下面的代码只将数组中的第一个元素设置为值2，并将所有其他元素设置为0:

\begin{cpp}
int myArray[3] { 2 };
\end{cpp}

要获取基于堆栈的C风格数组的大小，可以使用std::size()函数，该函数在<array>中定义，返回std::size\_t，这是在<cstddef>中定义的无符号整数类型:

\begin{cpp}
std::size_t arraySize { std::size(myArray) };
\end{cpp}

\begin{myNotic}{NOTE}
旧代码中，可能会看到size\_t使用时没有std命名空间的限定，没有使用using namespace std，也没有使用using std::size\_t。当使用import std时，这种方式不再有效，因为import std会将std命名空间中的所有内容导入到此。需要使用std::size\_t，或者使用适当的using指令或声明。第11章解释了可以导入名为std.compat的模块，而非std，但这不推荐用于新代码。
\end{myNotic}

\CXXTwentythreeLogo{-40}{-50}

\begin{myNotic}{NOTE}
C++23为类型std::size\_t引入了一个字面值后缀uz，例如：42uz。
\end{myNotic}

获取基于堆栈的C风格数组大小的技巧是使用sizeof操作符，sizeof操作符返回其参数的大小(以字节为单位)。要获得基于堆栈的数组中的元素数，可以用数组的字节大小除以第一个元素的字节大小:

\begin{cpp}
std::size_t arraySize { sizeof(myArray) / sizeof(myArray[0]) };
\end{cpp}

前面的例子展示了整数的一维数组，可以将其视为一排整数，每个整数都有自己的编号隔间。C++允许多维数组，可以将二维数组想象为一个棋盘，每个位置都有x轴位置和y轴位置。三维数组可以想象为立方体，而更高维度的数组更难可视化。下面的代码展示了创建一个用于井字游戏的字符二维数组的语法，然后在中心方块放置一个“o”：

\begin{cpp}
char ticTacToeBoard[3][3];
ticTacToeBoard[1][1] = 'o';
\end{cpp}

图1.1显示了该板与每个正方形的位置的可视化表示。

\myGraphic{0.6}{content/part1/chapter1/images/1.png}{图 1.1}

\mySubsubsection{1.1.15.}{std::array}

上一节讨论的数组来自C，但在C++中仍然可以工作。C++为固定大小的容器提供了一个特殊类型std::array，定义在<array>中，是对C风格数组的一个浅包装。

std::array有许多优点，容器总是知道自己的大小，不会自动转换为指针以避免某些类型的错误，并且有迭代器以便于遍历元素。下面的例子演示了如何使用数组容器，数组类型是一个类模板，接受一些类模板参数，允许指定在容器中存储多少元素，以及其类型。通过在array后面的尖括号内指定类模板参数，来为类模板参数提供类模板实参，例如 array<int,3>。

第12章介绍了模板，但现在只需记住，必须在尖括号之间指定两个参数；第一个代表数组中元素的类型，第二个代表数组的大小。

\begin{cpp}
array<int, 3> arr { 9, 8, 7 };
println("Array size = {}", arr.size());
println("2nd element = {}", arr[1]);
\end{cpp}

C++支持类模板参数推导（CTAD），这会第12章中详细介绍。现在只需要记住，这允许避免为某些类模板在尖括号之间指定模板参数。CTAD仅在使用初始化器时有效，编译器使用这个初始化器来自动推导模板参数。这对std::array有效，允许将前面的数组改为：

\begin{cpp}
array arr { 9, 8, 7 };
\end{cpp}

\begin{myNotic}{NOTE}
C风格的数组和std::array有固定的大小，必须在编译时知道，其长度不能在运行时改变。
\end{myNotic}

若想要一个动态大小的数组，建议使用std::vector。当向vector中添加新元素时，其大小会自动增加。

\mySubsubsection{1.1.16.}{std::vector}

C++标准库提供了许多不同的非固定大小的容器，在<vector>中声明的std::vector就是这种容器。vector类用一种更加灵活和安全的机制，可以取代了C风格数组。

使用者不需要担心内存管理，因为vector会自动分配足够的内存来容纳其元素。vector是动态的，可以在运行时添加和删除元素。第18章更详细地介绍了容器，vector的基本使用非常简单，这就是为什么它会在本书的开始部分介绍。下面的代码演示了vector的基本功能：


\begin{cpp}
// Create a vector of integers.
vector<int> myVector { 11, 22 };

// Add some more integers to the vector using push_back().
myVector.push_back(33);
myVector.push_back(44);

// Access elements.
println("1st element: {}", myVector[0]);
\end{cpp}

myVector声明为vector<int>。需要使用尖括号来指定模板参数，就像使用std::array时一样。vector是一个通用容器，可以包含几乎任何类型的对象，但vector中的所有元素必须是同一类型，这个类型在尖括号之间指定。

就像std::array一样，vector类模板也支持CTAD，可以这样定义myVector:

\begin{cpp}
vector myVector { 11, 22 };
\end{cpp}

同样，CTAD需要初始化列表才能工作。以下代码是非法的:

\begin{cpp}
vector myVector;
\end{cpp}

要向vector中添加元素，可以使用push\_back()成员函数。可以使用与数组类似的语法访问单个元素，即操作符[]。

\mySubsubsection{1.1.17.}{std::pair}

std::pair类模板定义在<utility>头文件中，其将两个可能不同类型的值组合在一起。这些值可以通过 first 和 second 公共数据成员访问。下面是一个例子：

\begin{cpp}
pair<double, int> myPair { 1.23, 5 };
println("{} {}", myPair.first, myPair.second);
\end{cpp}

pair也支持CTAD，所以可以这样定义myPair:

\begin{cpp}
pair myPair { 1.23, 5 };
\end{cpp}

\begin{myNotic}{NOTE}
虽然可以编写一个返回std::pair的函数，但是建议编写一个包含两个值的小型结构体或类，并从函数中返回该结构体或类的实例。返回pair的缺点是调用端代码必须使用first和second来访问这两个值，通过返回一个合适的结构体或类，可以给这两个值赋予更有意义的名称。
\end{myNotic}

\mySubsubsection{1.1.18.}{std::optional}

std::optional定义在<optional>中，保存一个特定类型的值，或者不保存任何值。

若想要允许参数是可选的，可以使用optional作为函数的参数。它也经常作为函数的返回类型，若函数可能返回某个值，也可能不返回任何值。这消除了从函数返回“特殊”值（如nullptr、-1、EOF等）的需要，还消除了将函数编写为返回一个布尔值（表示成功或失败），同时将函数的实际结果存储在作为输出参数（一个类型为非常量引用的参数，稍后在章节中讨论）传递给函数的需求。

optional类型是一个类模板，因此需要在尖括号之间指定需要的实际类型，例如 optional<int>。这种语法类似于vector中指定存储的类型，例如 vector<int>。

下面是一个返回optional对象的函数示例:

\begin{cpp}
optional<int> getData(bool giveIt)
{
    if (giveIt) {
        return 42;
    }
    return nullopt; // or simply return {};
}
\end{cpp}

可以这样调用这个函数:

\begin{cpp}
optional<int> data1 { getData(true) };
optional<int> data2 { getData(false) };
\end{cpp}

要确定optional对象是否有值，可以使用has\_value()成员函数，或者在if语句中直接使用optional对象:

\begin{cpp}
println("data1.has_value = {}", data1.has_value());
if (!data2) {
    println("data2 has no value.");
}
\end{cpp}

若optional对象有一个值，可以使用value()或解引用操作符*来检索：

\begin{cpp}
println("data1.value = {}", data1.value());
println("data1.value = {}", *data1);
\end{cpp}

若对一个空的optional对象使用value()，将会抛出一个std::bad\_optional\_access异常。

value\_or()可以用来返回optional的值，或者当optional为空时返回另一个值：

\begin{cpp}
println("data2.value = {}", data2.value_or(0));
\end{cpp}

不能在optional中存储引用（将在本章后面讨论），因此optional<T\&>将不起作用，但可以在optional中存储指针。

\mySubsubsection{1.1.19.}{结构化绑定}

结构化绑定允许声明多个变量，这些变量可以从数组、结构体或对组等数据结构中初始化。

假设有如下的std::array:

\begin{cpp}
array values { 11, 22, 33 };
\end{cpp}

可以使用结构化绑定声明三个变量x、y和z，并使用数组中的三个值来初始化它们。对于结构化绑定，必须使用auto关键字，不能使用int代替auto。

\begin{cpp}
auto [x, y, z] { values };
\end{cpp}

使用结构化绑定声明的变量数量必须与右侧表达式中的值数量相匹配。

若结构体中的所有非静态成员都是public，结构化绑定也可以用于结构体：

\begin{cpp}
struct Point { double m_x, m_y, m_z; };
Point point;
point.m_x = 1.0; point.m_y = 2.0; point.m_z = 3.0;
auto [x, y, z] { point };
\end{cpp}

作为最后一个例子，下面的代码片段将一对中的元素分解为单独的变量:

\begin{cpp}
pair myPair { "hello", 5 };
auto [theString, theInt] { myPair }; // Decompose using structured bindings.
println("theString: {}", theString);
println("theInt: {}", theInt);
\end{cpp}

还可以使用结构化绑定语法创建一组非常量引用或常量引用，通过使用auto\&或 const auto\&代替auto。非常量引用和常量引用都将在本章后面讨论。

\mySubsubsection{1.1.20.}{循环}

计算机非常适合一遍又一遍地做相同的事情。C++提供了四种循环机制：while循环、do/while循环、for循环和基于范围的for循环。

\mySamllsection{while循环}

while循环允许重复执行一个代码块，只要表达式的计算结果为true。下面这段代码输出“This is silly”五次:

\begin{cpp}
int i { 0 };
while (i < 5) {
    println("This is silly.");
    ++i;
}
\end{cpp}

关键字break可以在循环内部使用，用于立即退出循环并从紧随循环之后的代码行开始继续执行程序。关键字continue可以用于返回到循环顶部并重新计算while中的表达式，它会导致程序的执行跳来跳去，所以在循环中使用continue通常认为是不良风格，应该尽量少用。

\mySamllsection{do/while循环}

while循环有一种变体，称为do/while循环。它的工作方式与while循环类似，不同之处在于要执行的代码放在前面，而是否继续的条件的检查发生在最后。可以使用循环来实现，当希望某个代码块至少执行一次，并根据某些条件可能执行更多次的情况。下面的例子即使条件最终为false，也会打印一次语句：“This is silly.”：

\begin{cpp}
int i { 100 };
do {
    println("This is silly.");
    ++i;
} while (i < 5);
\end{cpp}

\mySamllsection{for循环}

for循环提供了另一种循环的语法。任何for循环都可以转换为while循环，反之亦然。for循环的语法通常更方便，因为它从起始表达式、结束条件和每次迭代结束时执行的表达式的角度来看待循环。在下面的代码中，i初始化为0；只要i小于5，循环就会继续；并且每次迭代的结束时，i会递增1。这段代码实现了与前面while循环示例相同的功能，但由于起始值、结束条件和每次迭代的语句都在一行中可见，因此可读性更强。

\begin{cpp}
for (int i { 0 }; i < 5; ++i) {
    println("This is silly.");
}
\end{cpp}

\mySamllsection{基于范围的循环}

基于范围的for循环是第四种循环机制，可以轻松地遍历容器中的元素。这种类型的循环适用于C风格的数组、初始化列表（本章后面讨论），以及支持begin()和end()函数返回迭代器的类型（参见第17章），例如std::array、vector和第18章中讨论的所有其他标准库容器。

下面的例子首先定义了一个包含四个整数的数组。基于范围的for循环然后遍历这个数组的每个元素的副本，并打印出每个值。要遍历元素本身而不制作副本，请使用引用变量。

\begin{cpp}
array arr { 1, 2, 3, 4 };
for (int i : arr) { println("{}", i); }
\end{cpp}

\mySamllsection{基于范围的for循环——初始化式}

可以在基于范围的for循环中使用初始化列表，类似于if和switch语句的初始化式：

\begin{cpp}
for (<initializer>; <range-declaration> : <range-expression>) { <body> }
\end{cpp}

<initializer>中引入的任何变量仅在<range-declaration>、<range-expression>和<body>中可用，在基于范围的for循环外部不可用：

\begin{cpp}
for (array arr { 1, 2, 3, 4 }; int i : arr) { println("{}", i); }
\end{cpp}

\mySubsubsection{1.1.21.}{初始化列表}

初始化列表在<initializer\_list>中定义，使得编写可以接受可变数量参数的函数变得容易。std::initializer\_list类型是一个类模板，要求在尖括号之间指定列表中元素的类型，类似于在vector中指定存储的元素类型。下面的例子展示了如何使用初始化列表：

\begin{cpp}
import std;
using namespace std;

int sum(initializer_list<int> values)
{
    int total { 0 };
    for (int value : values) {
        total += value;
    }
    return total;
}
\end{cpp}

通过一个整数初始化列表作为参数，函数sum()可以使用一个整数的大括号初始化器作为参数来调用，函数体使用基于范围的for循环来累加总和。这个函数可以这样使用：

\begin{cpp}
int a { sum({ 1, 2, 3 }) };
int b { sum({ 10, 20, 30, 40, 50, 60 }) };
\end{cpp}

初始化列表是类型安全的，列表中的所有元素必须是相同类型。对于这里的sum()函数，初始化列表中的所有元素必须是整数。尝试使用double调用，会导致编译错误或警告，错误信息中会指出，将double转换为int需要窄化转换。

\begin{cpp}
int c { sum({ 1, 2, 3.0 }) };
\end{cpp}

\mySubsubsection{1.1.22.}{C++中的字符串}

C++中有两种处理字符串的方法:

\begin{itemize}
\item
C风格:将字符串表示为字符数组

\item
C++风格:用更容易使用和更安全的字符串类型包装C风格的数组
\end{itemize}

第2章提供了详细的介绍。现在，只需要知 C++的std::string类型定义在<string>中，并且可以像使用基本类型一样使用C++字符串：

\begin{cpp}
string myString { "Hello, World" };
println("The value of myString is {}", myString);
println("The second letter is {}", myString[1]);
\end{cpp}

\mySubsubsection{1.1.23.}{C++——面向对象的语言}

若您是一个C程序员，可能会将本章到目前为止所介绍的特性视为对C语言的有益补充。正如C++这个名字所暗示的，从许多方面来说，这种语言只是“更好的C”。但这种观点忽略了一个问题：与C不同，C++是一种面向对象的语言。

面向对象编程（OOP）是一种不同、可以说是更自然的编写代码的方式。若习惯了C或Pascal等过程式语言，不必担心。第5章涵盖了需要了解的背景知识，以帮助读者们理解面向对象的范式。若已经了解OOP的理论，本节的其余部分将帮助各位快速掌握（或刷新记忆）C++对象的基本语法。

\mySamllsection{定义类}

C++中，类定义了对象的特点。类通常在模块接口文件（.cppm）中定义和导出，而实现可以直接在相同的模块接口文件中，或者在一个相应的模块实现文件（.cpp）中。

以下示例展示了一个“机票”类的定义，这个类可以根据飞行里程和客户是否是精英超级奖励计划的成员，来计算机票价格。

定义首先声明了类名。在一对花括号内，声明了类的数据成员（属性）和成员函数（行为）。每个数据成员和成员函数都与一个特定的访问级别相关联：公有（public）、保护（protected）或私有（private）。这些标签可以以任意顺序出现，并且可以重复。公有成员可以从类外部访问，而私有成员不能从类外部任何地方访问。保护成员可以被派生类访问，第10章将详细解释继承上下文中的派生类。建议将所有数据成员设为私有，并在需要时，使用公有或保护的获取方法（getters）来从对象检索数据，以及使用公有或保护的设置方法（setters）来为对象设置数据。这样，可以轻松地更改数据的表示形式，同时保持公有/保护接口不变。

编写模块接口文件时，请记住使用export module声明来指定正在编写哪个模块，并明确导出希望向模块用户提供的数据类型。

\begin{cpp}
export module airline_ticket;

import std;

export class AirlineTicket
{
    public:
        AirlineTicket();
        ~AirlineTicket();
        double calculatePriceInDollars();
        std::string getPassengerName();
        void setPassengerName(std::string name);
        int getNumberOfMiles();
        void setNumberOfMiles(int miles);
        bool hasEliteSuperRewardsStatus();
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string m_passengerName;
        int m_numberOfMiles;
        bool m_hasEliteSuperRewardsStatus;
};
\end{cpp}

本书遵循一个约定，即给类的每个数据成员加上一个以小写字母m开头，后跟一个下划线的前缀，例如m\_passengerName。

具有与类相同名称且没有返回类型的成员函数是构造函数。当创建类的一个对象时，自动调用。以波浪号（~）字符开头，后跟类名称的成员函数是析构函数。当对象销毁时，其会自动调用。

.cppm模块接口文件定义了类，而本例中成员函数的实现位于.cpp模块实现文件中。这个源文件以以下模块声明开始，告诉编译器这是airline\_ticket模块的一个源文件：

\begin{cpp}
module airline_ticket;
\end{cpp}

C++有几种方法可以初始化类的数据成员。一种方法是使用构造函数初始化列表，跟在构造函数头部的冒号之后。以下是一个使用构造函数初始化列表的AirlineTicket构造函数示例：

\begin{cpp}
AirlineTicket::AirlineTicket()
    : m_passengerName { "Unknown Passenger" }
    , m_numberOfMiles { 0 }
    , m_hasEliteSuperRewardsStatus { false }
{}
\end{cpp}

第二个选择是将初始化放在构造函数的主体中:

\begin{cpp}
AirlineTicket::AirlineTicket()
{
    // Initialize data members.
    m_passengerName = "Unknown Passenger";
    m_numberOfMiles = 0;
    m_hasEliteSuperRewardsStatus = false;
}
\end{cpp}

若只是初始化数据成员而不做其他事情，则并不真正需要构造函数，因为数据成员可以直接在类定义内初始化，这也称为类内初始化。可以修改类定义中的数据成员以初始化它们，而不是编写一个AirlineTicket构造函数：

\begin{cpp}
private:
    std::string m_passengerName { "Unknown Passenger" };
    int m_numberOfMiles { 0 };
    bool m_hasEliteSuperRewardsStatus { false };
\end{cpp}

若类还需要执行其他类型的初始化，例如打开文件、分配内存等，则需要编写一个构造函数来处理这些初始化。

下面是AirlineTicket类的析构函数：

\begin{cpp}
AirlineTicket::~AirlineTicket()
{
    // Nothing to do in terms of cleanup
}
\end{cpp}

这个析构函数不做任何事情，可以从这个类中删除。这里只显示它，是为了让读者了解析构函数的语法。若需要执行一些清理操作，例如关闭文件、释放内存等，则需要使用析构函数。

其他AirlineTicket类成员函数的定义如下:

\begin{cpp}
double AirlineTicket::calculatePriceInDollars()
{
    if (hasEliteSuperRewardsStatus()) {
        // Elite Super Rewards customers fly for free!
        return 0;
    }
    // The cost of the ticket is the number of miles times 0.1.
    // Real airlines probably have a more complicated formula!
    return getNumberOfMiles() * 0.1;
}

string AirlineTicket::getPassengerName() { return m_passengerName; }
void AirlineTicket::setPassengerName(string name) { m_passengerName = name; }

int AirlineTicket::getNumberOfMiles() { return m_numberOfMiles; }
void AirlineTicket::setNumberOfMiles(int miles) { m_numberOfMiles = miles; }

bool AirlineTicket::hasEliteSuperRewardsStatus()
{
    return m_hasEliteSuperRewardsStatus;
}

void AirlineTicket::setHasEliteSuperRewardsStatus(bool status)
{
    m_hasEliteSuperRewardsStatus = status;
}
\end{cpp}

也可以将成员函数实现直接放在模块接口文件中:

\begin{cpp}
export class AirlineTicket
{
    public:
        double calculatePriceInDollars()
        {
            if (hasEliteSuperRewardsStatus()) { return 0; }
            return getNumberOfMiles() * 0.1;
        }

        std::string getPassengerName() { return m_passengerName; }
        void setPassengerName(std::string name) { m_passengerName = name; }

        int getNumberOfMiles() { return m_numberOfMiles; }
        void setNumberOfMiles(int miles) { m_numberOfMiles = miles; }

        bool hasEliteSuperRewardsStatus() { return m_hasEliteSuperRewardsStatus; }
        void setHasEliteSuperRewardsStatus(bool status)
        {
            m_hasEliteSuperRewardsStatus = status;
        }
    private:
        std::string m_passengerName { "Unknown Passenger" };
        int m_numberOfMiles { 0 };
        bool m_hasEliteSuperRewardsStatus { false };
};
\end{cpp}

\mySamllsection{使用类}

要使用AirlineTicket类，首先需要导入其模块:

\begin{cpp}
import airline_ticket;
\end{cpp}

下面的示例程序使用了这个类。下面的例子展示了如何创建一个基于堆栈的AirlineTicket对象:

\begin{cpp}
AirlineTicket myTicket;
myTicket.setPassengerName("Sherman T. Socketwrench");
myTicket.setNumberOfMiles(700);
double cost { myTicket.calculatePriceInDollars() };
println("This ticket will cost ${}", cost);
\end{cpp}

AirlineTicket示例展示了创建和使用类的通用语法。

\mySubsubsection{1.1.24.}{范围解析}

作为C++开发者，需要熟悉作用域的概念，其定义了项目的可见性。程序中的每个名称（包括变量、函数和类名）都在某个作用域内。可以使用命名空间、函数定义、由花括号分隔的块，以及类定义来创建作用域。在for循环和基于范围的for循环的初始化语句中，初始化的变量作用于该for循环，并在该for循环之外不可见。若在if或switch语句的初始化表达式中初始化了变量，则该变量作用于该if或switch语句，并且在该语句之外不可见。尝试访问变量、函数或类时，首先在最近的外围作用域中查找该名称，然后是父作用域，以此类推，直到全局作用域。不在命名空间、函数、花括号分隔的块或类中的名称，都会假定为在全局作用域中。若在全局作用域中没有找到，此时编译器会生成一个未定义符号错误。

有时作用域中的名称会隐藏其他作用域中的同名名称，想要的作用域不是从程序中特定行的默认作用域解析的一部分。若不希望对名称使用默认的作用域解析，可以使用作用域解析操作符::来限定具有特定作用域的名称。以下示例演示了这一点。该示例定义了一个带有get()成员函数的Demo类，一个全局作用域的get()函数，以及一个位于NS命名空间中的get()函数。

\begin{cpp}
class Demo
{
    public:
    int get() { return 5; }
};

int get() { return 10; }

namespace NS
{
    int get() { return 20; }
}
\end{cpp}

全局作用域未命名，但可以单独使用作用域解析操作符(没有名称前缀)来访问，不同的get()函数可以按如下方式调用。这个例子中，代码本身在main()函数中，所以也在全局作用域中:

\begin{cpp}
int main()
{
    Demo d;
    println("{}", d.get()); // prints 5
    println("{}", NS::get()); // prints 20
    println("{}", ::get()); // prints 10
    println("{}", get()); // prints 10
}
\end{cpp}

若将前面的命名空间NS定义为未命名/匿名命名空间，即没有命名的命名空间:

\begin{cpp}
namespace
{
    int get() { return 20; }
}
\end{cpp}

将在全局作用域中定义一个get()，而在未命名的名称空间中定义另一个get()，所以下面这行代码将导致关于歧义名称解析的编译错误。

\begin{cpp}
println("{}", get());
\end{cpp}

若在main()函数之前添加以下using指令，也会出现同样的错误:

\begin{cpp}
using namespace NS;
\end{cpp}

\mySubsubsection{1.1.25.}{统一初始化}

C++11之前，类型的初始化并不总是统一的。以下对圆的定义，一个是结构体，一个是类：

\begin{cpp}
struct CircleStruct
{
    int x, y;
    double radius;
};

class CircleClass
{
    public:
        CircleClass(int x, int y, double radius)
            : m_x { x }, m_y { y }, m_radius { radius } {}
    private:
        int m_x, m_y;
        double m_radius;
};
\end{cpp}

C++11之前，CircleStruct类型变量和CircleClass类型变量的初始化不同:

\begin{cpp}
CircleStruct myCircle1 = { 10, 10, 2.5 };
CircleClass myCircle2(10, 10, 2.5);
\end{cpp}

对于结构体，可以使用\{…\}语法。但对于类，需要使用函数表示法调用构造函数:(…)。

C++11起，可以更统一地使用\{…\}语法初始化类型:

\begin{cpp}
CircleStruct myCircle3 = { 10, 10, 2.5 };
CircleClass myCircle4 = { 10, 10, 2.5 };
\end{cpp}

myCircle4的定义自动调用CircleClass的构造函数。甚至等号也是可选的:

\begin{cpp}
CircleStruct myCircle5 { 10, 10, 2.5 };
CircleClass myCircle6 { 10, 10, 2.5 };
\end{cpp}

作为另一个例子，Employee结构体初始化如下所示:

\begin{cpp}
Employee anEmployee;
anEmployee.firstInitial = 'J';
anEmployee.lastInitial = 'D';
anEmployee.employeeNumber = 42;
anEmployee.salary = 80'000;
\end{cpp}

使用统一初始化可重写为:

\begin{cpp}
Employee anEmployee { 'J', 'D', 42, 80'000 };
\end{cpp}

统一初始化并不局限于结构和类，可以用来初始化C++中的任何东西。下面的代码用值3初始化所有四个变量:

\begin{cpp}
int a = 3;
int b(3);
int c = { 3 }; // Uniform initialization
int d { 3 }; // Uniform initialization
\end{cpp}

统一初始化可用于对变量进行零初始化，只需指定一组空花括号:

\begin{cpp}
int e { }; // Uniform initialization, e will be 0
\end{cpp}

这种语法也可以用于结构体。若按照以下方式创建一个Employee结构体的实例，则其数据成员将进行默认初始化，对于像char和int这样的基本类型来说，将包含随机数据：

\begin{cpp}
Employee anEmployee;
\end{cpp}

若像下面这样创建实例，则所有的数据成员都是零初始化:

\begin{cpp}
Employee anEmployee { };
\end{cpp}

使用统一初始化的一个好处是可以防止窄化。当使用旧式赋值语法初始化变量时，C++会进行隐式窄化:

\begin{cpp}
int main()
{
    int x = 3.14;
}
\end{cpp}

C++在main()函数中使用以下语句时，C++会自动将3.14截断为3，然后将其赋值给x。一些编译器可能会发出关于这种窄化的警告，不应该忽视窄化转换，这可能会导致错误。使用统一初始化时，若的编译器完全符合C++11标准，那么对x的赋值必须生成编译错误：

\begin{cpp}
int x { 3.14 }; // Error because narrowing
\end{cpp}

若需要一个窄化转换，建议使用Guidelines Support Library(GSL)中提供的gsl::narrow\_cast()函数。这个函数用于执行显式的窄化转换，并且会在运行时检查转换的有效性，若转换不合法，会抛出一个异常。

统一初始化也可以用在构造函数初始化列表中，用于初始化类的成员数组。例如：

\begin{cpp}
class MyClass
{
    public:
        MyClass()
            : m_array { 0, 1, 2, 3 }
        {
        }
    private:
        int m_array[4];
};
\end{cpp}

统一初始化也可以用于标准库容器，比如std::vector。

\begin{myNotic}{NOTE}
建议使用统一初始化来代替赋值语法来初始化变量。本书在可能的情况下，都使用了统一初始化。
\end{myNotic}

\mySamllsection{指定初始化}

指定初始化器使用数据成员的名称来初始化聚合体类型的数据成员，聚合体类型是指数组类型的对象，或者是满足以下条件的结构体或类的对象：只有公共数据成员，没有用户声明或继承的构造函数，没有虚函数（参见第10章），并且没有虚拟、私有或保护的基类（参见第10章）。指定初始化，后面跟着数据成员的名称，必须按照数据成员的声明顺序排列。不允许混合使用指定初始化器和非指定初始化。没有使用指定初始化的数据成员，都将使用它们的默认值进行初始化：

\begin{itemize}
\item
具有类内初始化项的数据成员将获得该值。

\item
没有类内初始化项的数据成员会使用零初始化。
\end{itemize}

来看一下修改过的Employee结构体，salary数据成员的默认值为75,000。

\begin{cpp}
struct Employee {
    char firstInitial;
    char lastInitial;
    int employeeNumber;
    int salary { 75'000 };
};
\end{cpp}

前面的Employee结构体使用统一初始化语法初始化:

\begin{cpp}
Employee anEmployee { 'J', 'D', 42, 80'000 }
\end{cpp}

使用指定初始化式:

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D',
    .employeeNumber = 42,
    .salary = 80'000
};
\end{cpp}

与统一初始化相比，使用指定初始化的好处是更容易理解在初始化什么。

使用指定初始化，可以跳过对某些成员的初始化，若对这些成员的默认值感到满意。创建一个员工时，可以跳过初始化employeeNumber。因为没有类内初始化，所以employeeNumber将使用零初始化：

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D',
    .salary = 80'000
};
\end{cpp}

使用统一的初始化语法，必须将员工编号指定为0:

\begin{cpp}
Employee anEmployee { 'J', 'D', 0, 80'000 };
\end{cpp}

若跳过如下初始化salary数据成员，则salary将获得其默认值，即其在类中的初始化值75,000:

\begin{cpp}
Employee anEmployee {
    .firstInitial = 'J',
    .lastInitial = 'D'
};
\end{cpp}

当成员添加到数据结构中时，使用指定初始化，现有的代码可以继续工作，新的数据成员将使用其默认值进行初始化。

\mySubsubsection{1.1.26.}{指针和动态内存}

动态内存允许使用编译时不固定大小的数据构建程序，大多数重要的程序都以某种形式使用动态内存。

\mySamllsection{栈和堆}

C++应用程序中，内存可分为两部分——栈和堆。将栈可视化为一副扑克牌的一种方式。当前顶部的牌代表程序的当前作用域，通常是当前正在执行的函数。当前函数内部声明的所有变量都会占用栈帧顶部，即牌堆顶。若当前函数foo()调用另一个函数bar()，则会在牌堆上放置一张新牌，以便bar()有自己的栈帧来工作。从foo()传递到bar()的所有参数，都会从foo()栈帧复制到bar()栈帧。图1.2展示了在执行函数foo()时，其中声明了两个整数值的栈可能的样子。

\myGraphic{0.3}{content/part1/chapter1/images/2.png}{图1.2}

栈帧的好处在于，为每个函数提供了一个独立的内存工作空间。若在foo()栈帧内声明了一个变量，调用bar()函数不会改变它，除非明确告诉它要这样做。当foo()函数运行完毕后，栈帧消失，函数内部声明的所有变量不再占用内存。栈分配的变量不需要程序员进行释放（删除），这会自动发生。

堆是一个与当前函数或栈帧完全独立的内存区域。若想在函数完成后仍然让变量存在，可以将变量放在堆上。程序可以向堆中添加新的位，或者修改已经存在的位。开发者必须确保删除在堆上分配的内存。这不会自动发生，除非使用智能指针，这在第7章中会详细介绍。

\begin{myWarning}{WARNING}
在历史代码中，可能会看到指针。现代代码中，只有在不涉及所有权的情况下才允许使用原始/裸指针。否则，应该使用第7章中的智能指针。
\end{myWarning}

\mySamllsection{使用指针}

可以通过显式地方式，为其在堆上分配内存。要将一个整数放入堆区，需要分配内存，但首先需要声明指针:

\begin{cpp}
int* myIntegerPointer;
\end{cpp}

int类型后跟的*，表示声明的变量指向某个整数内存，将指针想象为指向动态分配内存的箭头。因为还没有给它分配给任何东西，所以目前它还没有指向特定位置，是一个未初始化的变量。应该始终避免使用未初始化的变量，尤其是未初始化的指针，其可能指向内存中的某个随机位置。这样的指针很可能会导致程序崩溃。这就是为什么需要在声明指针的同时对其进行初始化！若不想立即分配内存，可以将其初始化为空指针：

\begin{cpp}
int* myIntegerPointer { nullptr };
\end{cpp}

空指针是一个特殊的默认值，不是一个有效的指针，在布尔表达式中使用时转换为false:

\begin{cpp}
if (!myIntegerPointer) { /* myIntegerPointer is a null pointer. */ }
\end{cpp}

使用new操作符来分配内存:

\begin{cpp}
myIntegerPointer = new int;
\end{cpp}

指针只指向一个整数值的地址。要访问该值，需要对指针解引用。可以把解引用看作是跟随指针的箭头指向自由存储中的实际值。要设置新分配的自由存储整数的值:

\begin{cpp}
*myIntegerPointer = 8;
\end{cpp}

这并不等同于将myIntegerPointer设置为值8。这里不是更改指针，而是更改指针所指向的内存。若重新分配指针的值，将指向内存地址8，会导致程序崩溃。

使用完动态分配的内存后，需要使用delete操作符释放内存。为了防止在释放指针所指向的内存后继续使用指针，建议将其设置为nullptr（C++11引入，用于指针的空值，以区分NULL）：

\begin{cpp}
delete myIntegerPointer;
myIntegerPointer = nullptr;
\end{cpp}

\begin{myWarning}{WARNING}
指针在解引用之前必须有效，解引用空指针或未初始化的指针会导致未定义行为。程序可能会崩溃，但它也可能继续运行。
\end{myWarning}

指针并不总是指向空闲存储空间。可以声明一个指向堆栈上变量的指针，甚至可以声明另一个指针。要获取指向变量的指针，可以使用\& ("address of")操作符:

\begin{cpp}
int i { 8 };
int* myIntegerPointer { &i }; // Points to the variable with the value 8
\end{cpp}

C++有一种特殊的语法来处理指向结构体或类的指针。若有一个指向结构体或类的指针，可以首先使用*解引用，然后使用正常的.语法来访问其字段，如下面的代码片段所示。该代码片段还演示了如何动态分配和释放一个Employee实例。

\begin{cpp}
Employee* anEmployee { new Employee { 'J', 'D', 42, 80'000 } };
println("{}", (*anEmployee).salary);
delete anEmployee; anEmployee = nullptr;
\end{cpp}

->(箭头)操作符允许在一个步骤中同时执行解引用和字段访问。下面的语句等价于之前的println()，但更容易阅读:

\begin{cpp}
println("{}", anEmployee->salary);
\end{cpp}

还记得本章前面讨论过的短路逻辑吗?这可以与指针结合使用，以避免使用无效指针:

\begin{cpp}
bool isValidSalary { anEmployee && anEmployee->salary > 0 };
\end{cpp}

或者:

\begin{cpp}
bool isValidSalary { anEmployee != nullptr && anEmployee->salary > 0 };
\end{cpp}

解引用anEmployee以获取薪水值，前提是它是一个有效的指针。若它是一个空指针，逻辑操作会短路，不会解引用anEmployee指针。

\mySamllsection{动态分配数组}

堆也可用于动态分配数组，可以使用new[]操作符为数组分配内存。

\begin{cpp}
int arraySize { 8 };
int* myVariableSizedArray { new int[arraySize] };
\end{cpp}

这将分配足够的内存来保存arraySize整数，图1.3显示了执行这段代码后堆栈和堆存储的样子。指针变量仍然驻留在堆栈中，但是动态创建的数组驻留在堆区中。

\myGraphic{1.0}{content/part1/chapter1/images/3.png}{图1.3}

现在内存已经分配，可以使用myVariableSizedArray，就好像是基于堆栈的数组:

\begin{cpp}
myVariableSizedArray[3] = 2;
\end{cpp}

使用完数组后，应该将数组从堆区中删除。C++可以使用delete[]来完成这个工作:

\begin{cpp}
delete[] myVariableSizedArray;
myVariableSizedArray = nullptr;
\end{cpp}

delete后面的括号表示正在删除一个数组!

\begin{myNotic}{NOTE}
若确实需要动态分配的内存，避免使用C语言中的malloc()和free()。请使用C++中的new和delete，或者new[]和delete[]。在现代C++中，我们的目标是完全避免使用new、delete、new[]和delete[]，而使用更现代的结构，如标准库容器（例如std::vector）和智能指针。
\end{myNotic}

\begin{myWarning}{WARNING}
为了防止内存泄漏，每个对new的调用都应该与delete的调用配对，每个对new[]的调用都应该与delete[]的调用配对。不调用delete或delete[]，或者调用不匹配，会导致内存泄漏。
\end{myWarning}

\mySamllsection{空指针常量}

C++11之前，在<cstddef>中定义的常量NULL用于空指针。不能使用import声明来访问这个常量，必须使用\#include <cstddef>。NULL简单地定义为常数0，这可能会导致问题:

\begin{cpp}
#include <cstddef>

void func(int i) { /* ... */ }

int main()
{
    func(NULL);
}
\end{cpp}

代码定义了一个带有单个整数参数的函数func()。main()函数使用参数NULL调用func()，这个参数应该是一个空指针常量。由于NULL实际上并不是一个真正的指针，而是与整数0相同，因此触发了对func(int)的调用，一些编译器会对此发出警告。

通过使用真正的空指针常量nullptr，可以避免这个问题。下面的代码使用了真正的空指针常量，并且由于没有接受指针的func()重载，以下代码会导致编译错误：

\begin{cpp}
func(nullptr);
\end{cpp}

\mySubsubsection{1.1.27.}{const的用法}

C++关键字const有几种不同的使用方式，其用途是相关的，但存在一些细微的差异。const的微妙之处会使其成为面试中的绝佳问题！const关键字是“constant”（常量）的缩写，指定某些内容保持不变。

编译器通过将尝试更改它的行为，标记为错误来强制执行这一要求。当启用优化时，编译器可以利用这一提示来生成更好的代码。

\mySamllsection{const作为类型的限定符}

若认为关键字const与常量有关，那么您已经正确地发现了它的一个用途。在C语言中，开发者经常使用预处理\#define机制（参见第11章）来声明在程序执行期间不会改变的值的符号名，例如版本号。C++不鼓励使用\#define，而使用const来定义常量。使用const定义常量就像定义变量一样，不同之处在于编译器保证了代码无法更改该值：

\begin{cpp}
const int versionNumberMajor { 2 };
const int versionNumberMinor { 1 };
const std::string productName { "Super Hyper Net Modulator" };
const double PI { 3.141592653589793238462 };
\end{cpp}

可以将变量标记为const，包括全局变量和类数据成员。

\mySamllsection{const成员函数}

当变量通过指针包含一个或多个间接层时，使用const变得更加棘手。看看下面的代码行:

\begin{cpp}
int* ip;
ip = new int[10];
ip[4] = 5;
\end{cpp}

假设将const应用于ip，是想防止修改ip变量，还是想避免修改它指向的值？也就是说，是想避免第二条语句执行，还是第三条语句执行？

为了避免修改指向的值（如第三条语句所示），可以在声明ip时添加关键字const：

\begin{cpp}
const int* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!
\end{cpp}

现在就不能更改ip所指向的值。另一种语义上等价的写法如下所示:

\begin{cpp}
int const* ip;
ip = new int[10];
ip[4] = 5; // DOES NOT COMPILE!
\end{cpp}

将const放在int型的前面或后面对其功能没有影响。

若想将ip本身标记为const(而不是它所指向的值):

\begin{cpp}
int* const ip { nullptr };
ip = new int[10]; // DOES NOT COMPILE!
ip[4] = 5; // Error: dereferencing a null pointer
\end{cpp}

既然ip本身不能更改，编译器要求在声明时初始化，可以像前面的代码一样使用nullptr，也可以像下面这样使用新分配的内存:

\begin{cpp}
int* const ip { new int[10] };
ip[4] = 5;
\end{cpp}

也可以像这样把指针和所指向的值都标记为const:

\begin{cpp}
int const* const ip { nullptr };
\end{cpp}

下面是另一种等价的语法:

\begin{cpp}
const int* const ip { nullptr };
\end{cpp}

这种语法看起来令人困惑，但实际上有一个简单的规则:const关键字适用于直接在其左边的内容。再看看这句:

\begin{cpp}
int const* const ip { nullptr };
\end{cpp}

从左到右，第一个const紧跟在int这个词的右边，适用于ip指向的int，不能更改ip指向的值。第二个const放在*的右边，适用于指向int的指针，即ip变量，不能更改ip（指针）本身。

这条规则变得令人困惑的原因是，第一个const可以放在变量前面：

\begin{cpp}
const int* const ip { nullptr };
\end{cpp}

这种“异常”语法比其他语法更常用。

可以将此规则进行扩展，如下例所示:

\begin{cpp}
const int * const * const * const ip { nullptr };
\end{cpp}

\begin{myNotic}{NOTE}
这里有一个容易记住的规则，有助于理解复杂的变量声明：从右向左阅读。例如，int* const ip 从右向左读作“ip是一个指向int的常量指针。”进一步，int const* ip 读作“ip是一个指向常量int的指针”，而const int* ip 读作“ip是一个指向int常量的指针。”
\end{myNotic}

\mySamllsection{使用const保护参数}

C++可以将非常量变量强制转换为常量变量，这样做可以在一定程度上避免其他代码更改该变量。若要调用一个由同事编写的函数，并且确保该函数不改变传入的值，可以告诉同事让该函数接受一个常量参数。若该函数尝试更改参数的值，则代码将无法顺利编译。

以下代码中，string*自动转换为mysteryFunction()调用中的const string*。若mysteryFunction()的作者尝试修改传入的字符串的值，代码将无法编译。虽然有一些方法可以绕过这种限制，但需要付出额外的努力。C++仅保护避免意外更改常量变量。


\begin{cpp}
void mysteryFunction(const string* someString)
{
    *someString = "Test"; // Will not compile
}

int main()
{
    string myString { "The string" };
    mysteryFunction(&myString); // &myString is a string*
}
\end{cpp}

还可以对基本类型参数使用const，以避免在函数体中对其进行修改。下面的函数有一个const整型形参，函数体中不能修改参数整数。若尝试修改，编译器将会报错。

\begin{cpp}
void func(const int param) { /* Not allowed to change param... */ }
\end{cpp}

\mySamllsection{const成员函数}

const关键字的第二个用途是标记类成员函数为const，防止修改类数据成员。之前引入的AirlineTicket类，可以将所有只读成员函数标记为const。const必须添加到成员函数的声明和定义中，若const成员函数尝试修改AirlineTicket的一个数据成员，编译器将报错。

\begin{cpp}
export class AirlineTicket
{
    public:
        double calculatePriceInDollars() const;

        std::string getPassengerName() const;
        void setPassengerName(std::string name);

        int getNumberOfMiles() const;
        void setNumberOfMiles(int miles);

        bool hasEliteSuperRewardsStatus() const;
        void setHasEliteSuperRewardsStatus(bool status);
    private:
        std::string m_passengerName { "Unknown Passenger" };
        int m_numberOfMiles { 0 };
        bool m_hasEliteSuperRewardsStatus { false };
};

std::string AirlineTicket::getPassengerName() const
{
    return m_passengerName;
}
// Other member functions omitted...
\end{cpp}

\begin{myNotic}{NOTE}
为了遵循const正确性原则，建议将不改变对象的数据成员的成员函数声明为const。与非const成员函数的mutator相比，这些成员函数也称为检查器(inspector)。
\end{myNotic}

\mySubsubsection{1.1.28.}{引用}

专业的C++代码，包括本书中的大部分代码，大量使用引用。在C++中，引用是另一个变量的别名。对引用的所有修改都会改变其所指向变量的值。可以将引用视为隐式的指针，省去了获取变量地址和解引用指针的麻烦，也可以将引用视为原始变量的另一个名称。可以创建独立的引用变量，在类中使用引用数据成员，将引用作为函数参数接受，并从函数返回引用。

\mySamllsection{引用变量}

引用变量必须在创建后立即初始化，如下所示:

\begin{cpp}
int x { 3 };
int& xRef { x };
\end{cpp}

将\&添加到类型表明该变量是引用。该变量仍然当作一个普通的变量来使用，但它实际上是一个指向原始变量的指针。变量x和引用变量xRef都指向相同的值，xRef只是x的另一个名字。若改变了其中一个值，另一个的值也会改变。下面的代码通过xRef将x设置为10:

\begin{cpp}
xRef = 10;
\end{cpp}

若不初始化引用变量，就不能在类定义之外声明。

\begin{cpp}
int& emptyRef; // DOES NOT COMPILE!
\end{cpp}

\begin{myWarning}{WARNING}
引用变量在创建时必须初始化。
\end{myWarning}

\mySamllsection{修改引用}

C++中的引用一旦初始化后就不能更改，始终指向初始化时指定的变量。引用的语法可能会对初学者造成混淆。若在声明引用时将一个变量赋值给该引用，则该引用指向该变量。但在此之后将另一个变量赋值给该引用，则更改的是引用所指向的变量的值，而不是更新引用以指向被赋值的变量。下面是一个代码示例：

\begin{cpp}
int x { 3 }, y { 4 };
int& xRef { x };
xRef = y; // Changes value of x to 4. Doesn't make xRef refer to y.
\end{cpp}

可以尝试通过在赋值时，获取y的地址来绕过这个限制:

\begin{cpp}
xRef = &y; // DOES NOT COMPILE!
\end{cpp}

这段代码无法编译。变量y的地址是一个指针，但xRef声明为对int的引用，而不是对指针的引用。

一些开发者在尝试绕过引用的预期语义方面走得更远。若将一个引用赋值给另一个引用会怎样？难道这不会让第一个引用指向第二个引用所引用的变量吗？可以尝试以下代码：

\begin{cpp}
int x { 3 }, z { 5 };
int& xRef { x };
int& zRef { z };
zRef = xRef; // Assigns values, not references
\end{cpp}

最后的语句不会改变zRef所引用的内容。它将z的值设置为3，因为xRef引用的x是3。

\begin{myWarning}{WARNING}
当引用初始化为指向一个特定的变量，就不能将其更改为指向另一个变量，只能更改所引用变量的值。
\end{myWarning}

\mySamllsection{const引用}

引用上使用const通常比在指针上使用const容易，原因有二。首先，引用默认就是const的，不能更改它们所引用的对象，没有必要显式地标记为const。其次，不能创建一个引用的引用，所以通常引用只有一层，获取多层引用的唯一方法是创建一个指向指针的引用。

当C++开发者提到一个对const的引用时，通常这样：

\begin{cpp}
int z;
const int& zRef { z };
zRef = 4; // DOES NOT COMPILE
\end{cpp}

对int\&使用const，可以避免对zRef的赋值。与指针类似，const int\& zRef等同于int const\& zRef，但将zRef标记为const对z没有影响。以通过直接更改z来修改z的值，而不是通过引用。

但不能创建对未命名值的引用，比如整数字面量，除非引用是对const值的引用。以下示例中，unnamedRef1无法编译，它是对常量的非常量引用，可能会改变常量5的值，这没有意义。unnamedRef2有效，因为它是对const的引用，所以不能写为unnamedRef2 = 7。

\begin{cpp}
int& unnamedRef1 { 5 }; // DOES NOT COMPILE
const int& unnamedRef2 { 5 }; // Works as expected
\end{cpp}

对于临时对象也是如此。不能创建对临时对象的非const引用，但可以创建对const的引用。假设以下函数返回一个std::string对象:

\begin{cpp}
string getString() { return "Hello world!"; }
\end{cpp}

可以为调用getString()的结果创建一个对const的引用，该引用会使临时std::string对象保持活动状态，直到该引用超出作用域:

\begin{cpp}
string& string1 { getString() }; // DOES NOT COMPILE
const string& string2 { getString() }; // Works as expected
\end{cpp}

\mySamllsection{指针的引用和引用的指针}

可以创建对任何类型的引用，包括指针类型。下面是一个引用int型指针的例子:

\begin{cpp}
int* intP { nullptr };
int*& ptrRef { intP };
ptrRef = new int;
*ptrRef = 5;
delete ptrRef; ptrRef = nullptr;
\end{cpp}

这个语法可能看起来有点奇怪：可能不习惯看到*和\&紧挨在一起。其语义很简单：ptrRef是对intP的引用，而intP是一个指向int的指针，修改ptrRef会改变intP。指向指针引用并不常见，但偶尔会这样用。

取一个引用的地址与取该引用所引用变量的地址，会得到相同的结果：

\begin{cpp}
int x { 3 };
int& xRef { x };
int* xPtr { &xRef }; // Address of a reference is pointer to value.
*xPtr = 100;
\end{cpp}

通过取x的引用的地址来设置xPtr指向x，将100赋值给*xPtr会将x的值更改为100。因为类型不匹配，比较xPtr == xRef将无法编译；xPtr是一个指向int的指针，而xRef是int的引用。比较xPtr == \&xRef和xPtr == \&x都可以编译且不会出错，并且都为true。

最后不能声明对引用的引用或对引用的指针，不允许使用int\&\&或int\&*。

\mySamllsection{结构化绑定和引用}

本章前面介绍了结构化绑定:

\begin{cpp}
pair myPair { "hello", 5 };
auto [theString, theInt] { myPair }; // Decompose using structured bindings
\end{cpp}

了解了引用和const变量，其也可以与结构化绑定结合使用:

\begin{cpp}
auto& [theString, theInt] { myPair }; // Decompose into references-to-non-const
const auto& [theString, theInt] { myPair }; // Decompose into references-to-const
\end{cpp}

\mySamllsection{引用数据成员}

类的数据成员可以是引用，但引用不能独立存在，必须引用某个其他变量，而且不能更改引用指向的位置。引用数据成员不能在类构造函数的主体内部初始化，必须在构造函数的初始化列表中初始化。语法上，构造函数初始化列表紧随构造函数之后，以冒号开始。以下是一个带有构造函数初始化列表的示例。

\begin{cpp}
class MyClass
{
    public:
        MyClass(int& ref) : m_ref { ref } { /* Body of constructor */ }
    private:
        int& m_ref;
};
\end{cpp}

\begin{myWarning}{WARNING}
引用在创建时必须初始化，声明引用时创建引用，但引用数据成员需要在包含类的构造函数初始化项中进行初始化。
\end{myWarning}

\mySamllsection{引用参数}

C++开发者通常不使用独立的引用变量或引用数据成员。引用的最常见用途是作为函数的参数，默认的参数传递语义是按值传递：函数接收其参数的副本。当修改这些参数时，原始参数保持不变。在C语言中，指针常用于函数修改其他栈帧中的变量。通过解引用指针，函数可以更改表示变量的内存，即使该变量不在当前的栈帧中。这种方法的问题在于，将指针语法带入了实际上非常简单的任务中。

C++提供了一种更好的机制，称为按引用传递，其中参数是引用而不是指针，以替代将指针传递给函数。以下是addOne()函数的两种实现。它是按值传递的，第一种对传递进来的变量没有影响，因此函数接收的是传递给它的值的副本。第二种使用引用，因此改变了原始变量。

\begin{cpp}
void addOne(int i)
{
    i++; // Has no real effect because this is a copy of the original
}

void addOne(int& i)
{
    i++; // Actually changes the original variable
}
\end{cpp}

使用整数引用调用addOne()函数的语法与函数只接受整数的语法没什么不同。

\begin{cpp}
int myInt { 7 };
addOne(myInt);
\end{cpp}

\begin{myNotic}{NOTE}
两个addOne()实现之间有一个区别。使用按值传递的版本可以毫无问题地接受字面量，addOne(3); 是合法的。若使用按引用传递的addOne()版本尝试做同样的事情，将会导致编译错误。这可以通过使用下一节讨论的常量引用参数来解决。
\end{myNotic}

下面是另一个引用传递派上用场的例子。这是一个简单的交换函数，用于交换两个int型的值:

\begin{cpp}
void swap(int& first, int& second)
{
    int temp { first };
    first = second;
    second = temp;
}
\end{cpp}

可以这样调用:

\begin{cpp}
int x { 5 }, y { 6 };
swap(x, y);
\end{cpp}

使用x和y作为参数调用swap()时，第一个参数被初始化为引用x，第二个参数初始化为引用y。当swap()修改first和second时，实际上是改变了x和y的值。

当有一个指向需要在函数中传递的引用的指针时，常见的问题就出现了，可以通过解引用指针来“转换”指针为引用。这个操作给了指针指向的值，编译器然后用这个值来初始化引用参数。可以这样调用swap()：

\begin{cpp}
int x { 5 }, y { 6 };
int *xp { &x }, *yp { &y };
swap(*xp, *yp);
\end{cpp}

最后，若有函数需要返回一个复制成本较高的类的对象，经常会看到这个函数接受一个非const引用的输出参数，然后函数修改这个参数，而不是直接返回这样的对象。开发者们认为这是推荐的方法，以避免在从函数返回对象时创建副本带来的性能损失。编译器通常足够智能，能够避免任何冗余的复制，因此有以下规则：

\begin{myWarning}{WARNING}
从函数返回对象的推荐方法是按值返回，而不是使用输出参数。
\end{myWarning}

\mySamllsection{通过常量引用}

常量引用（reference-to-const）参数的主要价值在于效率。将一个值传递给函数时，会制作整个值的副本。传递一个引用时，实际上只是传递了一个指向原始值的指针，不需要生成副本。通过传递一个引用到常量，两全其美：不制作副本，并且不更改原始变量。处理对象时，引用到常量变得更加重要，因为对象可能很大，复制可能会有不良的副作用。以下示例显示了如何将std::string作为引用到常量传递给函数：

\begin{cpp}
import std;
using namespace std;
void printString(const string& myString) { println("{}", myString); }

int main()
{
    string someString { "Hello World" };
    printString(someString);
    printString("Hello World"); // Passing literals works.
}
\end{cpp}

\mySamllsection{传递引用 和 传递值}

希望修改参数并希望函数接收的变量反映这些更改时，需要使用按引用传递。应该只将按引用传递限制在这些情况下。按引用传递避免了将参数复制到函数中，其有两个好处：

\begin{itemize}
\item
提高效率：按值传递参数时，函数参数会创建一个副本，这可能导致性能下降，尤其是当参数是大型对象时。按引用传递则避免了这一复制过程，从而提高了函数调用效率。

\item
增强代码清晰度：按引用传递参数表明函数会修改参数的值，这有助于提高代码的可读性和可维护性。开发者可以清楚地知道哪些参数会修改，哪些不会。并非所有类都允许按值传递。
\end{itemize}

若希望利用这些优点，但又不希望修改原始对象，则应该将参数标记为const，从而通过引用传递到const。

\begin{myNotic}{NOTE}
这些按引用传递的好处，应该仅对那些不需要修改参数的简单内置类型（如int和double）使用按值传递。若需要将一个对象传递给一个函数，最好是通过引用const，而非按值传递。这样可以防止不必要的复制。若函数需要修改对象，请通过引用非const进行传递。第9章中，引入移动语义后，会修改了这个规则，允许在某些情况下按值传递对象。
\end{myNotic}

\mySamllsection{引用返回值}

可以从函数返回一个引用，只有当返回的引用所引用的变量在函数终止后还存在，才能使用这种技术。

\begin{myWarning}{WARNING}
从函数中，永远不要返回对局部作用域为该函数变量的引用，例如：在堆栈上自动分配的变量，该变量将在函数结束时销毁。
\end{myWarning}

返回引用的一个主要原因是，想要能够直接将返回值作为左值（赋值语句的左侧）进行赋值。许多重载操作符通常返回引用，例如操作符=、+=等。

从函数返回引用的另一个原因是，返回类型复制成本较高。通过返回引用或引用到常量，可以避免复制。但请记住之前的警告，这通常用于从类成员函数返回通过引用到常量的对象。

\mySamllsection{引用和指针}

C++中可以用引用做的所有事情，都可以用指针来完成。可以像这样编写前面显示的swap()函数:

\begin{cpp}
void swap(int* first, int* second)
{
    int temp { *first };
    *first = *second;
    *second = temp;
}
\end{cpp}

这种代码比使用引用的版本更混乱。引用使程序更清晰、更容易理解,也比指针更安全：不可能有空引用，因此不会遇到与指针类似的错误。这些关于引用更安全的论点，只在没有指针的情况下才有效，看一下以下接受一个整数引用的函数：

\begin{cpp}
void refcall(int& t) { ++t; }
\end{cpp}

可以声明一个指针并将其初始化为指向内存中的某个随机位置。可以解引用这个指针并将其作为引用参数传递给refcall()，如下面代码所示。这段代码可以正常编译，但在执行时可能会发生未定义行为，可能会导致程序崩溃。

\begin{cpp}
int* ptr { (int*)8 };
refcall(*ptr);
\end{cpp}

大多数时候，可以用引用代替指针。对象的引用也支持多态性，这与指向对象的指针的方式相同。但有些情况下需要使用指针，当需要更改它所指向的位置时，不能更改引用所引用的变量。当动态分配内存时，需要将指向结果的指针存储在一个指针中，而不是一个引用中。可选指针的另一个用例是，其可以是nullptr，还有一个用例是想在容器中存储多态类型。

历史遗留代码中，区分指针和引用参数和返回类型适当使用的办法是考虑谁拥有内存。若接收变量的代码成为所有者，并因此负责释放与对象关联的内存，必须接收指向对象的指针。若接收变量的代码不需要释放内存，将接收一个引用。现在，应该避免使用原始指针，而应使用智能指针，这是传递内存所有权推荐的方式。

\begin{myNotic}{NOTE}
首选引用，而非指针。只有在不能使用引用时才使用指针。
\end{myNotic}

假设一个函数，将一个整数数组分成两个数组：一个包含偶数，另一个包含奇数。函数不知道源数组中会有多少个偶数或奇数，在检查源数组后应动态分配两个新数组的内存，还应该返回两个新数组的大小。总共需要返回四个项目：两个新数组的指针和两个新数组的大小，必须使用按引用传递。标准的C可以编写如下函数：

\begin{cpp}
void separateOddsAndEvens(const int arr[], size_t size, int** odds,
    size_t* numOdds, int** evens, size_t* numEvens)
{
    // Count the number of odds and evens.
    *numOdds = *numEvens = 0;
    for (size_t i = 0; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            ++(*numOdds);
        } else {
            ++(*numEvens);
        }
    }

    // Allocate two new arrays of the appropriate size.
    *odds = new int[*numOdds];
    *evens = new int[*numEvens];

    // Copy the odds and evens to the new arrays.
    size_t oddsPos = 0, evensPos = 0;
    for (size_t i = 0; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            (*odds)[oddsPos++] = arr[i];
        } else {
            (*evens)[evensPos++] = arr[i];
        }
    }
}
\end{cpp}

该函数的最后四个参数是“引用”参数。为了改变它们所引用的值，separateOddsAndEvens()必须对其进行解引用，这导致了函数体内的丑陋语法。想要调用separateOddsAndEvens()时，必须传递两个指针的地址，这样函数才能改变实际的指针，并传递两个size\_t的地址，这样函数才能改变实际的size\_t。还有，调用者需要负责删除separateOddsAndEvens()创建的两个数组！

\begin{cpp}
int unSplit[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int* oddNums { nullptr };
int* evenNums { nullptr };
size_t numOdds { 0 }, numEvens { 0 };

separateOddsAndEvens(unSplit, std::size(unSplit),
    &oddNums, &numOdds, &evenNums, &numEvens);

// Use the arrays...

delete[] oddNums; oddNums = nullptr;
delete[] evenNums; evenNums = nullptr;
\end{cpp}

若对这种语法感到厌烦(应该如此)，可以通过使用引用来获得真正的按引用传递语义，来编写相同的函数:

\begin{cpp}
void separateOddsAndEvens(const int arr[], size_t size, int*& odds,
    size_t& numOdds, int*& evens, size_t& numEvens)
{
    numOdds = numEvens = 0;
    for (size_t i { 0 }; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            ++numOdds;
        } else {
            ++numEvens;
        }
    }

    odds = new int[numOdds];
    evens = new int[numEvens];

    size_t oddsPos { 0 }, evensPos { 0 };
    for (size_t i { 0 }; i < size; ++i) {
        if (arr[i] % 2 == 1) {
            odds[oddsPos++] = arr[i];
        } else {
            evens[evensPos++] = arr[i];
        }
    }
}
\end{cpp}

这时，odds和evens参数是int的引用。separateOddsAndEvens()可以修改作为函数参数使用的int（通过引用），而无需显式解引用。同样的逻辑适用于numOdds和numEvens，是size\_t的引用。使用这个函数版本，不再需要传递指针或size\_t的地址；引用参数会自动处理。

\begin{cpp}
separateOddsAndEvens(unSplit, std::size(unSplit),
    oddNums, numOdds, evenNums, numEvens);
\end{cpp}

尽管使用引用参数已经比使用指针更清晰，但建议尽可能避免使用动态分配的数组。通过使用标准库中的vector容器，separateOddsAndEvens()函数可以重写为更安全、更短、更优雅且更易读的版本，并且所有内存分配和释放自动进行。

\begin{cpp}
void separateOddsAndEvens(const vector<int>& arr,
    vector<int>& odds, vector<int>& evens)
{
    for (int i : arr) {
        if (i % 2 == 1) {
            odds.push_back(i);
        } else {
            evens.push_back(i);
        }
    }
}
\end{cpp}

可以这样使用:

\begin{cpp}
vector<int> vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
vector<int> odds, evens;
separateOddsAndEvens(vecUnSplit, odds, evens);
\end{cpp}

不需要释放odds和evens容器，vector类会自动处理。这个版本比使用指针或引用的版本更容易使用。

vector已经比使用指针或引用的版本要好得多，但正如之前所建议的，应尽可能避免使用输出参数。若一个函数需要返回某个值，应该直接返回，而不是使用输出参数！自C++17以来，编译器不允许对形式为return object;的语句执行复制或移动操作，其中object是一个匿名临时变量。这称为强制省略复制/移动操作，通过值返回对象，但没有性能开销。若object是一个局部变量，不是函数参数，则允许执行非强制省略的复制/移动操作，这是称为命名返回值优化（NRVO）的优化方式。这个优化不是由标准保证的，一些编译器只在发布版本中执行此优化。通过强制省略和非强制省略，编译器可以避免从函数返回对象的副本，这就是一种零拷贝的按值传递语义。对于NRVO，尽管复制/移动构造函数不会调用，但仍然需要是可访问的；否则，根据标准，程序就是错误的。

以下是一个版本的separateOddsAndEvens()，返回一个简单的结构体，包含两个vector，而非接受两个输出vector作为参数，并使用指定初始化。

\begin{cpp}
struct OddsAndEvens { vector<int> odds, evens; };

OddsAndEvens separateOddsAndEvens(const vector<int>& arr)
{
    vector<int> odds, evens;
    for (int i : arr) {
        if (i % 2 == 1) {
            odds.push_back(i);
        } else {
            evens.push_back(i);
        }
    }
    return OddsAndEvens { .odds = odds, .evens = evens };
}
\end{cpp}

通过这些修改，使得调用separateOddsAndEvens()的代码更易于阅读和理解:

\begin{cpp}
vector<int> vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
auto oddsAndEvens { separateOddsAndEvens(vecUnSplit) };
// Do something with oddsAndEvens.odds and oddsAndEvens.evens...
\end{cpp}

\begin{myNotic}{NOTE}
避免输出参数。若一个函数需要返回一些东西，只需按值返回即可。
\end{myNotic}

\mySubsubsection{1.1.29.}{const\_cast()}

C++中每个变量都有特定的类型。某些情况下，可以将一个类型的变量强制转换为另一个类型的变量。为此，C++提供了五种类型的强制转换：const\_cast()、static\_cast()、reinterpret\_cast()、dynamic\_cast()和std::bit\_cast()。本节讨论const\_cast()。第二种强制转换类型static\_cast()会在本书的前期进行简要介绍，并在第10章中详细讨论，其他的强制转换会在第10章中详细介绍。

const\_cast()是可用的五种强制转换中最简单的一种，可以使用它向vector添加const属性，或者去除变量的const属性，它是五种强制转换中唯一允许去除const属性的。理论上，不应该有去除const的需求。若一个变量是const的，应该保持const。但实践中，有时会遇到这样的情况：一个函数指定要接收一个const参数，然后必须将其传递给一个接收非const参数的函数，并且确定后一个函数不会修改其非const参数。程序中保持const一致性的“正确”解决方案并不总是可行，尤其是使用第三方库时。有时需要去除变量的const属性，但应该只在确信调用的函数不会修改对象时才这样做；否则，没有其他选择，只能重构代码。以下是示例：

\begin{cpp}
void thirdPartyLibraryFunction(char* str);

void f(const char* str)
{
    thirdPartyLibraryFunction(const_cast<char*>(str));
}
\end{cpp}

此外，标准库提供了一个辅助函数std::as\_const()，定义在<utility>头文件中，返回其引用参数的引用到常量版本。as\_const(obj)等价于const\_cast<const T\&>(obj)，其中T是obj的类型。与使用const\_cast()相比，使用as\_const()可以得到更短且可读性更高的代码。as\_const()的具体用例将在本书的稍后部分介绍，但其基本用法如下所示：

\begin{cpp}
string str { "C++" };
const string& constStr { as_const(str) };
\end{cpp}

\mySubsubsection{1.1.30.}{异常}

C++是一种灵活的语言，允许进行不安全的事情。编译器允许在随机内存地址上乱写或尝试除以零（计算机不太擅长处理无穷大）的代码。C++中的一种可增加安全性的语言特性，就是异常处理。

异常是一个异常情况，是一个在程序的正常执行流中不期望或不想要的特殊情况。例如，正在编写一个函数来检索网页，可能会发生许多问题。可能包含网页的互联网主机可能无法访问，网页可能返回空白，或者连接可能丢失。处理这种情况的一种方法是函数返回一个特殊值，例如nullptr或一个错误代码。异常提供了一种更好的处理问题的机制。

异常伴随着一些新的术语。当代码检测到一个异常情况时，会抛出一个异常。另一段代码捕获异常并采取适当的行动。以下示例展示了一个名为divideNumbers()的函数，若调用者传递了一个除数为零的参数，会抛出一个异常。std::invalid\_argument异常在<stdexcept>头文件中定义。

\begin{cpp}
double divideNumbers(double numerator, double denominator)
{
    if (denominator == 0) {
        throw invalid_argument { "Denominator cannot be 0." };
    }
    return numerator / denominator;
}
\end{cpp}


当执行throw语句时，函数立即结束，不返回任何值。若调用者使用try/catch块围绕函数调用，如以下代码所示，可以接收到异常并能够处理它。第14章将更详细地介绍异常处理，现在只需记住，建议通过引用到常量来捕获异常，以下示例中的const invalid\_argument\&。此外，所有标准库异常类都有一个名为what()的成员函数，会返回一个包含异常简要解释的字符串。

\begin{cpp}
try {
    println("{}", divideNumbers(2.5, 0.5));
    println("{}", divideNumbers(2.3, 0));
    println("{}", divideNumbers(4.5, 2.5));
} catch (const invalid_argument& exception) {
    println("Exception caught: {}", exception.what());
}
\end{cpp}

第一个调用divideNumbers()执行成功，结果输出到屏幕上。第二个调用抛出了一个异常。没有返回值，并且只有当捕获异常时才会输出错误消息。第三个调用永远不会执行，第二个调用抛出了异常，导致程序跳转到catch块。前面代码段输出如下所示：

\begin{shell}
5
Exception caught: Denominator cannot be 0.
\end{shell}

C++处理异常可能会很复杂。为了正确使用异常，需要了解当异常抛出时栈变量的行为，并且需要小心地正确捕获和处理必要的异常。还需要在异常中包含更多关于错误的信息，可以编写自己的异常类型，C++编译器不会强制捕获可能发生的每个异常。若代码没有捕获异常，但抛出了异常，程序将终止。这些关于异常的更复杂方面在第14章中有详细介绍。

\mySubsubsection{1.1.31.}{类型别名}

类型别名提供了一个现有类型声明的新名称。可以将类型别名视为为现有类型声明引入同义词的语法，而不创建新类型。以下是将int*类型声明重命名为IntPtr的示例：

\begin{cpp}
using IntPtr = int*;
\end{cpp}

可以互换地使用新类型名称及其别名的定义:

\begin{cpp}
int* p1;
IntPtr p2;
\end{cpp}

使用新类型名称创建的变量，与使用原始类型声明创建的变量完全兼容。根据这些定义，以下代码完全有效，不仅仅是兼容的类型，类型也相同：

\begin{cpp}
p1 = p2;
p2 = p1;
\end{cpp}

类型别名最常见用途是在类型声明变得过于繁琐时，提供可管理的名称，这在模板中经常出现。标准库自身的示例是std::basic\_string<T>来表示字符串，其是一个类模板，其中T是字符串中每个字符的类型，例如char。每次想要引用此类类型时，都必须指定模板类型参数。声明变量、函数参数等时，必须这样写:basic\_string<char>：

\begin{cpp}
void processVector(const vector<basic_string<char>>& vec) { /* omitted */ }

int main()
{
    vector<basic_string<char>> myVector;
    processVector(myVector);
}
\end{cpp}

由于basic\_string<char>经常使用，标准库提供了以下类型别名作为更短、更有意义的名称：

\begin{cpp}
using string = basic_string<char>;
\end{cpp}

有了这个类型别名，前面的代码片段可以写得更优雅:

\begin{cpp}
void processVector(const vector<string>& vec) { /* omitted */ }

int main()
{
    vector<string> myVector;
    processVector(myVector);
}
\end{cpp}

\mySubsubsection{1.1.32.}{typedef}

类型别名是在C++11中引入的。C++11之前，为了实现类似的功能，必须使用typedef，但这种方式更为复杂。这个旧机制在这里解释一下，我们会在历史代码中看到。

就像类型别名一样，typedef也为现有类型声明提供了一个新名称：

\begin{cpp}
using IntPtr = int*;
\end{cpp}

可以使用typedef:

\begin{cpp}
typedef int* IntPtr;
\end{cpp}

这里的代码，可读性要差得多。因为顺序颠倒了，这导致了很多困惑，即使对于专业C++开发人员也是如此。除了更复杂之外，typedef的行为与类型别名相同，可以这样使用:

\begin{cpp}
IntPtr p;
\end{cpp}

类型别名和typedef并不完全等价。与typedef相比，类型别名在与模板一起使用时更加强大，因为需要更多关于模板的详细信息，所以会在第12章中介绍。

\begin{myNotic}{NOTE}
始终优先选择类型别名，而非typedef。
\end{myNotic}

\mySubsubsection{1.1.33.}{类型推断}

类型推断允许编译器自动推导表达式的类型。有两种关键字用于类型推断：auto和decltype。

\mySamllsection{auto关键字}

auto关键字有许多不同的用途:

\begin{itemize}
\item
推断函数的返回类型

\item
定义结构化绑定

\item
来推断表达式的类型

\item
推导非类型模板参数的类型

\item
定义简化的函数模板

\item
与decltype(auto)一起使用

\item
使用可选函数语法编写函数

\item
编写泛型Lambda表达式
\end{itemize}

auto可用于让编译器在编译时，自动推断变量的类型。下面的语句展示了auto关键字在该上下文中最简单的用法:

\begin{cpp}
auto x { 123 }; // x is of type int.
\end{cpp}

使用auto而非int类型并不会带来什么好处，当类型更复杂时，auto就变得有用了。假设有一个名为getFoo()的函数，其返回类型非常复杂。若想要将调用getFoo()的结果赋值给一个变量，可以显式地指定复杂的类型，或者简单地使用auto并让编译器来确定类型：

\begin{cpp}
auto result { getFoo() };
\end{cpp}

好处是，可以轻松地更改函数的返回类型。

\mySamllsection{auto\& 语法}

使用auto来推断表达式的类型，会去掉引用和const限定符。假设有如下代码:

\begin{cpp}
const string message { "Test" };
const string& foo() { return message; }
\end{cpp}

可以调用foo()并将结果存储在一个指定为auto类型的变量中:

\begin{cpp}
auto f1 { foo() };
\end{cpp}

auto去掉了引用和const限定符，所以f1的类型是string，生成了一个副本!若想要一个对const的引用，可以显式地将其设置为引用并将其标记为const:

\begin{cpp}
const auto& f2 { foo() };
\end{cpp}

本章前面介绍了as\_const()实用函数，返回其引用形参的引用到const版本。与auto一起使用as\_const()时要小心，由于auto去掉了引用和const限定符，下面的结果变量的类型是string，而不是const string\&，会进行复制:

\begin{cpp}
string str { "C++" };
auto result { as_const(str) };
\end{cpp}

\begin{myWarning}{WARNING}
始终记住auto会去掉引用和const限定符，创建一个副本!若不想要副本，请使用auto\&或const auto\&。
\end{myWarning}

\mySamllsection{auto* 语法}

auto关键字也可以用于指针:

\begin{cpp}
int i { 123 };
auto p { &i };
\end{cpp}

p的类型是int*。与前一节讨论的使用引用时不同，这里不存在创建副本的危险。当使用指针时，建议使用auto*语法，因为它更清楚地说明了指针的使用:

\begin{cpp}
auto* p { &i };
\end{cpp}

此外，使用auto*而不是仅仅使用auto确实解决了auto、const和指针一起使用时的奇怪行为。假设:

\begin{cpp}
const auto p1 { &i };
\end{cpp}

大多数时候，代码并没有按照期望进行操作!

通常，当使用const时，想要保护指针所指向的对象。可能会认为p1的类型是const int*，但其类型是int* const，所以它是一个指向非const整数的const指针!下面代码把const放在auto之后也没有帮助，类型仍然是int* const:

\begin{cpp}
auto const p2 { &i };
\end{cpp}

将auto*与const结合使用时，其行为就如期望的那样:

\begin{cpp}
const auto* p3 { &i };
\end{cpp}

现在p3的类型是const int*。若的想要一个const指针而不是一个const整数，可以把const放在末尾:

\begin{cpp}
auto* const p4 { &i };
\end{cpp}

p4的类型是int* const。

最后，使用这种语法:

\begin{cpp}
const auto* const p5 { &i };
\end{cpp}

p5的类型为const int* const。若省略*，则无法实现这一点。

\mySamllsection{复制列表和直接使用列表初始化}

有两种类型的初始化使用带括号的初始化列表:

\begin{itemize}
\item
复制列表初始化: T obj = \{arg1, arg2, ...\};

\item
直接使用列表初始化: T obj \{arg1, arg2, ...\};
\end{itemize}

与auto类型推导结合使用时，复制列表初始化和直接列表初始化之间有一个重要的区别。下面是一个例子:

\begin{cpp}
// Copy list initialization
auto a = { 11 }; // initializer_list<int>
auto b = { 11, 22 }; // initializer_list<int>

// Direct list initialization
auto c { 11 }; // int
auto d { 11, 22 }; // Error, too many elements.
\end{cpp}

对于复制列表初始化，大括号初始化式中所有元素必须具有相同的类型。例如，以下代码无法编译:

\begin{cpp}
auto b = { 11, 22.33 }; // Compilation error
\end{cpp}

\mySamllsection{decltype关键字}

decltype关键字接受一个表达式作为参数，并计算该表达式的类型:

\begin{cpp}
int x { 123 };
decltype(x) y { 456 };
\end{cpp}

编译器将y的类型推断为int，因为它是x的类型。

auto和decltype之间的区别在于，decltype不会剥离引用和const限定符。再次以函数foo()为例，该函数返回对const字符串的引用。使用下列decltype定义f2的结果是，f2的类型为const string\&，因此不进行复制:

\begin{cpp}
decltype(foo()) f2 { foo() };
\end{cpp}

乍一看，decltype似乎并没有什么价值，但它使用在模板的上下文中就十分强大了，会在第12章和第26章中继续介绍。

\mySubsubsection{1.1.34.}{标准库}

C++附带了一个标准库，其中包含了许多有用的类，这些类可以立即使用。这些类的优点是，不需要重新实现其功能。另一个优点是，标准库中的类已经由成千上万的用户进行了大量测试和验证，以确保其正确性。标准库中的类也经过性能优化，因此使用它们很可能会比自己的实现有更好的性能。

标准库提供了大量的功能。第16章到第24章会有更多介绍；当开始使用C++时，了解标准库可以为做些什么还挺重要。这对于C开发者来说尤其重要，C开发者可能会尝试以与C相同的方式在C++中解决问题，但在C++中，可能存在一个更简单、更安全的解决方案，涉及使用标准库中的类。

这就是为什么本章已经介绍了一些标准库的类，如std::string、array、vector、pair和optional。这些类在本书示例中一直在使用，以确保读者养成使用标准库类的好习惯，并会在第16章到第24章中会介绍更多的标准库类。







